<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link href="../default.css" type="text/css" rel="stylesheet">
<title> BLOP: function.cc </title>
</head>
<body>

<a href="../index.html" title="Home"> 
<img src="../home.png"  style="border-width:0cm;"> 
</a>
<a href="source.html" title="List of sourcefiles"> 
<img src="../up.png"    style="border-width:0cm;"> 
</a>
 <hr>
<pre>
<a name="__line0"></a>#include "<a href="function.h.html">function.h</a>"
<a name="__line1"></a>#include &lt;iostream&gt;
<a name="__line2"></a>#include &lt;sstream&gt;
<a name="__line3"></a>#include &lt;fstream&gt;
<a name="__line4"></a>#include &lt;cmath&gt;
<a name="__line5"></a>#include &lt;cstdio&gt;
<a name="__line6"></a>#include &lt;algorithm&gt;
<a name="__line7"></a>#include "<a href="config.h.html">config.h</a>"
<a name="__line8"></a>#include "<a href="exc.hh.html">exc.hh</a>"
<a name="__line9"></a>#include "<a href="pstream.h.html">pstream.h</a>"
<a name="__line10"></a>#include "<a href="constants.h.html">constants.h</a>"
<a name="__line11"></a>#include "<a href="warning.h.html">warning.h</a>"
<a name="__line12"></a>#include "<a href="cfunc_wrapper.hh.html">cfunc_wrapper.hh</a>"
<a name="__line13"></a>#include "<a href="function_core.hh.html">function_core.hh</a>"
<a name="__line14"></a>#include "<a href="dgraph.h.html">dgraph.h</a>"
<a name="__line15"></a>#include "<a href="bloputils.h.html">bloputils.h</a>"
<a name="__line16"></a>#include "<a href="interpolate.hh.html">interpolate.hh</a>"
<a name="__line17"></a>#include "<a href="blop_bookkeeper.h.html">blop_bookkeeper.h</a>"
<a name="__line18"></a>#include "<a href="geometry.h.html">geometry.h</a>"
<a name="__line19"></a>#include "<a href="blop_time.hh.html">blop_time.hh</a>"
<a name="__line20"></a>#include "<a href="plottable.h.html">plottable.h</a>"
<a name="__line21"></a>
<a name="__line22"></a>#ifdef HAVE_GSL
<a name="__line23"></a>#include &lt;gsl/gsl_sf_bessel.h&gt;
<a name="__line24"></a>#endif
<a name="__line25"></a>
<a name="__line26"></a>namespace blop
<a name="__line27"></a>{
<a name="__line28"></a>    <span class=comment>// void function::formula(const var &amp;)    -- is defined in blop_cint.cc and blop_nocint.cc</span>
<a name="__line29"></a>
<a name="__line30"></a>    using namespace function_core;
<a name="__line31"></a>
<a name="__line32"></a>    <span class=comment>// ---------- constructors and destructor  ----------------------------------------</span>
<a name="__line33"></a>
<a name="__line34"></a>    var function::tmp;
<a name="__line35"></a>
<a name="__line36"></a>    std::vector&lt;std::string&gt; function::column_names_;
<a name="__line37"></a>
<a name="__line38"></a>    int sample(dgraph &amp;g, double dx, double from, double to,
<a name="__line39"></a>	       const function &amp;f1,
<a name="__line40"></a>	       const function &amp;f2,
<a name="__line41"></a>	       const function &amp;f3,
<a name="__line42"></a>	       const function &amp;f4)
<a name="__line43"></a>    {
<a name="__line44"></a>	function f(f1,f2,f3,f4);
<a name="__line45"></a>	int n = (int)((to-from)/dx)+1;
<a name="__line46"></a>	g.columns(f.components());
<a name="__line47"></a>	g.resize(n);
<a name="__line48"></a>	std::vector&lt;blop::var&gt; args(1);
<a name="__line49"></a>	double x = from;
<a name="__line50"></a>	for(int i=0; i&lt;n; ++i, x += dx)
<a name="__line51"></a>	{
<a name="__line52"></a>	    args[0] = x;
<a name="__line53"></a>	    f.meval(args,g[i]);
<a name="__line54"></a>	}
<a name="__line55"></a>	return n;
<a name="__line56"></a>    }
<a name="__line57"></a>
<a name="__line58"></a>    int function::components() const
<a name="__line59"></a>    {
<a name="__line60"></a>	if(!base_) return 0;
<a name="__line61"></a>	return base_-&gt;n_out();
<a name="__line62"></a>    }
<a name="__line63"></a>
<a name="__line64"></a>    bool function::default_check_args_ = true;
<a name="__line65"></a>
<a name="__line66"></a>    void function::named_param(const var &amp;id, const var &amp;v)
<a name="__line67"></a>    {
<a name="__line68"></a>	function_core::named_param::values()[id] = v;
<a name="__line69"></a>    }
<a name="__line70"></a>    void function::named_params(const std::map&lt;std::string,blop::var&gt; &amp;v)
<a name="__line71"></a>    {
<a name="__line72"></a>        function_core::named_param::values() = v;
<a name="__line73"></a>    }
<a name="__line74"></a>    void function::clear_named_params()
<a name="__line75"></a>    {
<a name="__line76"></a>        function_core::named_param::values().clear();
<a name="__line77"></a>    }
<a name="__line78"></a>
<a name="__line79"></a>    bool function::equals(const function &amp;f) const
<a name="__line80"></a>    {
<a name="__line81"></a>	if(!base_ || !f.base_) return false;
<a name="__line82"></a>	return base_-&gt;equals(f.base_);
<a name="__line83"></a>    }
<a name="__line84"></a>
<a name="__line85"></a>    void function::copy_arg_ranges_(const function &amp;f1,
<a name="__line86"></a>				    const function &amp;f2,
<a name="__line87"></a>				    const function &amp;f3,
<a name="__line88"></a>				    const function &amp;f4,
<a name="__line89"></a>				    const function &amp;f5,
<a name="__line90"></a>				    const function &amp;f6)
<a name="__line91"></a>    {
<a name="__line92"></a>	vector&lt;const function *&gt; ff;
<a name="__line93"></a>	if(f1.initialized()) ff.push_back(&amp;f1);
<a name="__line94"></a>	if(f2.initialized()) ff.push_back(&amp;f2);
<a name="__line95"></a>	if(f3.initialized()) ff.push_back(&amp;f3);
<a name="__line96"></a>	if(f4.initialized()) ff.push_back(&amp;f4);
<a name="__line97"></a>	if(f5.initialized()) ff.push_back(&amp;f5);
<a name="__line98"></a>	if(f6.initialized()) ff.push_back(&amp;f6);
<a name="__line99"></a>
<a name="__line100"></a>	{
<a name="__line101"></a>	    unsigned int min_size = 0;
<a name="__line102"></a>	    for(int i=0; i&lt;(int)ff.size(); ++i)
<a name="__line103"></a>		if(min_size&lt;ff[i]-&gt;arg_min_.size()) min_size = ff[i]-&gt;arg_min_.size();
<a name="__line104"></a>	    arg_min_.resize(min_size,unset);
<a name="__line105"></a>	    for(unsigned int arg_i=0; arg_i&lt;arg_min_.size(); ++arg_i)
<a name="__line106"></a>	    {
<a name="__line107"></a>		arg_min_[arg_i] = unset;
<a name="__line108"></a>		for(unsigned int f_i=0; f_i&lt;ff.size(); ++f_i)
<a name="__line109"></a>		{
<a name="__line110"></a>		    if(arg_i&lt;ff[f_i]-&gt;arg_min_.size() &amp;&amp;
<a name="__line111"></a>		       ff[f_i]-&gt;arg_min_[arg_i] != unset &amp;&amp;
<a name="__line112"></a>		       ( ff[f_i]-&gt;arg_min_[arg_i] &gt; arg_min_[arg_i] ||
<a name="__line113"></a>			 arg_min_[arg_i] == unset))
<a name="__line114"></a>		    {
<a name="__line115"></a>			arg_min_[arg_i] = ff[f_i]-&gt;arg_min_[arg_i];
<a name="__line116"></a>		    }
<a name="__line117"></a>		}
<a name="__line118"></a>	    }
<a name="__line119"></a>	}
<a name="__line120"></a>	{
<a name="__line121"></a>	    unsigned int max_size = 0;
<a name="__line122"></a>	    for(int i=0; i&lt;(int)ff.size(); ++i)
<a name="__line123"></a>		if(max_size&lt;ff[i]-&gt;arg_max_.size()) max_size = ff[i]-&gt;arg_max_.size();
<a name="__line124"></a>	    arg_max_.resize(max_size,unset);
<a name="__line125"></a>	    for(unsigned int arg_i=0; arg_i&lt;arg_max_.size(); ++arg_i)
<a name="__line126"></a>	    {
<a name="__line127"></a>		arg_max_[arg_i] = unset;
<a name="__line128"></a>		for(unsigned int f_i=0; f_i&lt;ff.size(); ++f_i)
<a name="__line129"></a>		{
<a name="__line130"></a>		    if(arg_i&lt;ff[f_i]-&gt;arg_max_.size() &amp;&amp;
<a name="__line131"></a>		       ff[f_i]-&gt;arg_max_[arg_i] != unset &amp;&amp;
<a name="__line132"></a>		       ( ff[f_i]-&gt;arg_max_[arg_i] &lt; arg_max_[arg_i] ||
<a name="__line133"></a>			 arg_max_[arg_i] == unset))
<a name="__line134"></a>		    {
<a name="__line135"></a>			arg_max_[arg_i] = ff[f_i]-&gt;arg_max_[arg_i];
<a name="__line136"></a>		    }
<a name="__line137"></a>		}
<a name="__line138"></a>	    }
<a name="__line139"></a>	}
<a name="__line140"></a>
<a name="__line141"></a>    }
<a name="__line142"></a>
<a name="__line143"></a>
<a name="__line144"></a>    <span class=comment>// whenever the 'base_' vector is modified (or any of its element), this</span>
<a name="__line145"></a>    <span class=comment>// function should be called!!!!!</span>
<a name="__line146"></a>    void function::init_()
<a name="__line147"></a>    {
<a name="__line148"></a>	if(!base_) return;
<a name="__line149"></a>	result_.resize(base_-&gt;n_out());
<a name="__line150"></a>	parameters_.resize(base_-&gt;npars());
<a name="__line151"></a>	check_args_ = default_check_args_;
<a name="__line152"></a>    }
<a name="__line153"></a>
<a name="__line154"></a>#ifdef __MAKECINT__    
<a name="__line155"></a>    function::function(void *fptr)
<a name="__line156"></a>    {
<a name="__line157"></a>	<span class=comment>//nargs_ = npars_ = -1;</span>
<a name="__line158"></a>	base_ = new function_core::cfunc(fptr);
<a name="__line159"></a>	print_param_value_ = default_print_param_value_;
<a name="__line160"></a>	init_();
<a name="__line161"></a>    }
<a name="__line162"></a>#endif
<a name="__line163"></a>
<a name="__line164"></a>    function::function(const std::vector&lt;function::core*&gt; &amp;bases, bool clone_them)
<a name="__line165"></a>    {
<a name="__line166"></a>	if(bases.size() == 1)
<a name="__line167"></a>	{
<a name="__line168"></a>	    if(clone_them) base_ = bases[0]-&gt;clone();
<a name="__line169"></a>	    else base_ = bases[0];
<a name="__line170"></a>	}
<a name="__line171"></a>	else
<a name="__line172"></a>	{
<a name="__line173"></a>	    function_core::multiple *m = new function_core::multiple;
<a name="__line174"></a>	    base_ = m;
<a name="__line175"></a>	    m-&gt;base_.resize(bases.size());
<a name="__line176"></a>	    for(unsigned int i=0; i&lt;bases.size(); ++i)
<a name="__line177"></a>	    {
<a name="__line178"></a>		if(clone_them) m-&gt;base_[i] = bases[i]-&gt;clone();
<a name="__line179"></a>		else m-&gt;base_[i] = bases[i];
<a name="__line180"></a>	    }
<a name="__line181"></a>	    print_param_value_ = default_print_param_value_;
<a name="__line182"></a>	    init_();
<a name="__line183"></a>	}
<a name="__line184"></a>    }
<a name="__line185"></a>
<a name="__line186"></a>    function::function(const std::vector&lt;blop::var&gt; &amp;c)
<a name="__line187"></a>    {
<a name="__line188"></a>	if(!c.empty())
<a name="__line189"></a>	{
<a name="__line190"></a>	    if(c.size() == 1) base_ = new constant(c[0]);
<a name="__line191"></a>	    else
<a name="__line192"></a>	    {
<a name="__line193"></a>		function_core::multiple *m = new function_core::multiple;
<a name="__line194"></a>		base_ = m;
<a name="__line195"></a>		m-&gt;base_.resize(c.size());
<a name="__line196"></a>		for(unsigned int i=0; i&lt;c.size(); ++i) m-&gt;base_[i] = new constant(c[i]);
<a name="__line197"></a>	    }
<a name="__line198"></a>	    print_param_value_ = default_print_param_value_;
<a name="__line199"></a>	}
<a name="__line200"></a>	else base_ = 0;
<a name="__line201"></a>	init_();
<a name="__line202"></a>    }
<a name="__line203"></a>
<a name="__line204"></a>    function::function()
<a name="__line205"></a>    {
<a name="__line206"></a>	base_ = 0;
<a name="__line207"></a>	print_param_value_ = default_print_param_value_;
<a name="__line208"></a>	init_();
<a name="__line209"></a>    }
<a name="__line210"></a>
<a name="__line211"></a>    function::function(const function::core &amp;f)
<a name="__line212"></a>    {
<a name="__line213"></a>	base_ = f.clone();
<a name="__line214"></a>	print_param_value_ = default_print_param_value_;
<a name="__line215"></a>	init_();
<a name="__line216"></a>    }
<a name="__line217"></a>
<a name="__line218"></a>    function::function(function::core *f)
<a name="__line219"></a>    {
<a name="__line220"></a>	<span class=comment>//nargs_ = npars_ = -1;</span>
<a name="__line221"></a>	base_ = f;
<a name="__line222"></a>	print_param_value_ = default_print_param_value_;
<a name="__line223"></a>	init_();
<a name="__line224"></a>    }
<a name="__line225"></a>
<a name="__line226"></a>    function::function(double d)
<a name="__line227"></a>    {
<a name="__line228"></a>	if(d != unset) base_ = new constant(d);
<a name="__line229"></a>	else base_ = 0;
<a name="__line230"></a>	print_param_value_ = default_print_param_value_;
<a name="__line231"></a>	init_();
<a name="__line232"></a>    }
<a name="__line233"></a>    function::function(double d1, double d2)
<a name="__line234"></a>    {
<a name="__line235"></a>	if(d1==unset || d2==unset) warning::print("d1 or d2 is unset","function::function(double d1, double d2)");
<a name="__line236"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line237"></a>	base_ = m;
<a name="__line238"></a>	m-&gt;base_.resize(2);
<a name="__line239"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line240"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line241"></a>	print_param_value_ = default_print_param_value_;
<a name="__line242"></a>	init_();
<a name="__line243"></a>    }
<a name="__line244"></a>    function::function(double d1, double d2, double d3)
<a name="__line245"></a>    {
<a name="__line246"></a>	if(d1==unset || d2==unset || d3==unset) warning::print("d1 or d2 or d3 is unset","function::function(double d1, double d2, double d3)");
<a name="__line247"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line248"></a>	base_ = m;
<a name="__line249"></a>	m-&gt;base_.resize(3);
<a name="__line250"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line251"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line252"></a>	m-&gt;base_[2] = new constant(d3);
<a name="__line253"></a>	print_param_value_ = default_print_param_value_;
<a name="__line254"></a>	init_();
<a name="__line255"></a>    }
<a name="__line256"></a>    function::function(double d1, double d2, double d3, double d4)
<a name="__line257"></a>    {
<a name="__line258"></a>	if(d1==unset || d2==unset || d3==unset || d4==unset) warning::print("d1 or d2 or d3 or d4 is unset","function::function(double d1, double d2, double d3, double d4)");
<a name="__line259"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line260"></a>	base_ = m;
<a name="__line261"></a>	m-&gt;base_.resize(4);
<a name="__line262"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line263"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line264"></a>	m-&gt;base_[2] = new constant(d3);
<a name="__line265"></a>	m-&gt;base_[3] = new constant(d4);
<a name="__line266"></a>	print_param_value_ = default_print_param_value_;
<a name="__line267"></a>	init_();
<a name="__line268"></a>    }
<a name="__line269"></a>
<a name="__line270"></a>    function::function(int d1, double d2)
<a name="__line271"></a>    {
<a name="__line272"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line273"></a>	base_ = m;
<a name="__line274"></a>	m-&gt;base_.resize(2);
<a name="__line275"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line276"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line277"></a>	print_param_value_ = default_print_param_value_;
<a name="__line278"></a>	init_();
<a name="__line279"></a>    }
<a name="__line280"></a>
<a name="__line281"></a>    function::function(double d1, int d2)
<a name="__line282"></a>    {
<a name="__line283"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line284"></a>	base_ = m;
<a name="__line285"></a>	m-&gt;base_.resize(2);
<a name="__line286"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line287"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line288"></a>	print_param_value_ = default_print_param_value_;
<a name="__line289"></a>	init_();
<a name="__line290"></a>    }
<a name="__line291"></a>
<a name="__line292"></a>    function::function(int d1)
<a name="__line293"></a>    {
<a name="__line294"></a>	base_ = new constant(d1);
<a name="__line295"></a>	print_param_value_ = default_print_param_value_;
<a name="__line296"></a>	init_();
<a name="__line297"></a>    }
<a name="__line298"></a>    function::function(int d1, int d2)
<a name="__line299"></a>    {
<a name="__line300"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line301"></a>	base_ = m;
<a name="__line302"></a>	m-&gt;base_.resize(2);
<a name="__line303"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line304"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line305"></a>	print_param_value_ = default_print_param_value_;
<a name="__line306"></a>	init_();
<a name="__line307"></a>    }
<a name="__line308"></a>    function::function(int d1, int d2, int d3)
<a name="__line309"></a>    {
<a name="__line310"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line311"></a>	base_ = m;
<a name="__line312"></a>	m-&gt;base_.resize(3);
<a name="__line313"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line314"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line315"></a>	m-&gt;base_[2] = new constant(d3);
<a name="__line316"></a>	print_param_value_ = default_print_param_value_;
<a name="__line317"></a>	init_();
<a name="__line318"></a>    }
<a name="__line319"></a>    function::function(int d1, int d2, int d3, int d4)
<a name="__line320"></a>    {
<a name="__line321"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line322"></a>	base_ = m;
<a name="__line323"></a>	m-&gt;base_.resize(4);
<a name="__line324"></a>	m-&gt;base_[0] = new constant(d1);
<a name="__line325"></a>	m-&gt;base_[1] = new constant(d2);
<a name="__line326"></a>	m-&gt;base_[2] = new constant(d3);
<a name="__line327"></a>	m-&gt;base_[3] = new constant(d4);
<a name="__line328"></a>	print_param_value_ = default_print_param_value_;
<a name="__line329"></a>	init_();
<a name="__line330"></a>    }
<a name="__line331"></a>
<a name="__line332"></a>    function::function(const var &amp;v)
<a name="__line333"></a>    {
<a name="__line334"></a>	base_ = new constant(v);
<a name="__line335"></a>	print_param_value_ = default_print_param_value_;
<a name="__line336"></a>	init_();
<a name="__line337"></a>    }
<a name="__line338"></a>
<a name="__line339"></a>    function::function(const char *v)
<a name="__line340"></a>    {
<a name="__line341"></a>	base_ = new constant(v);
<a name="__line342"></a>	print_param_value_ = default_print_param_value_;
<a name="__line343"></a>	init_();
<a name="__line344"></a>    }
<a name="__line345"></a>
<a name="__line346"></a>    function::function(const string &amp;s)
<a name="__line347"></a>    {
<a name="__line348"></a>	base_ = new constant(s);
<a name="__line349"></a>	print_param_value_ = default_print_param_value_;
<a name="__line350"></a>	init_();
<a name="__line351"></a>    }
<a name="__line352"></a>
<a name="__line353"></a>    function::function(const function &amp;f)
<a name="__line354"></a>    {
<a name="__line355"></a>	parnames_ = f.parnames_;
<a name="__line356"></a>	if(f.base_) base_ = f.base_-&gt;clone();
<a name="__line357"></a>	else base_ = 0;
<a name="__line358"></a>	print_param_value_ = f.print_param_value_;
<a name="__line359"></a>	parameters_ = f.parameters_;
<a name="__line360"></a>
<a name="__line361"></a>	init_();
<a name="__line362"></a>
<a name="__line363"></a>	check_args_ = f.check_args_;
<a name="__line364"></a>
<a name="__line365"></a>	if(!f.derivatives_.empty())
<a name="__line366"></a>	{
<a name="__line367"></a>	    cerr&lt;&lt;"function::function(const function &amp;) does not yet copy the derivatives!"&lt;&lt;endl;
<a name="__line368"></a>	    cerr&lt;&lt;"Please strongly request the implementation of it by the author!!!"&lt;&lt;endl;
<a name="__line369"></a>	    exit(1);
<a name="__line370"></a>	}
<a name="__line371"></a>	default_args_ = f.default_args_;
<a name="__line372"></a>
<a name="__line373"></a>	copy_arg_ranges_(f);
<a name="__line374"></a>    }
<a name="__line375"></a>
<a name="__line376"></a>    function::function(const function &amp;f1, const function &amp;f2)
<a name="__line377"></a>    {
<a name="__line378"></a>	parnames_ = f1.parnames_;
<a name="__line379"></a>	for(unsigned int i=parnames_.size(); i&lt;f2.parnames_.size(); ++i)
<a name="__line380"></a>	    parnames_.push_back(f2.parnames_[i]);
<a name="__line381"></a>
<a name="__line382"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line383"></a>	base_ = m;
<a name="__line384"></a>	if(f1.initialized()) m-&gt;base_.push_back(f1.base_-&gt;clone());
<a name="__line385"></a>	if(f2.initialized()) m-&gt;base_.push_back(f2.base_-&gt;clone());
<a name="__line386"></a>
<a name="__line387"></a>	print_param_value_ = false;
<a name="__line388"></a>	if(f1.print_param_value_ || f2.print_param_value_) print_param_value_ = true;
<a name="__line389"></a>	{
<a name="__line390"></a>	    unsigned i=0;
<a name="__line391"></a>	    for(; i&lt;f1.parameters_.size(); ++i) parameters_.push_back(f1.parameters_[i]);
<a name="__line392"></a>	    for(; i&lt;f2.parameters_.size(); ++i) parameters_.push_back(f2.parameters_[i]);
<a name="__line393"></a>	}
<a name="__line394"></a>	init_();
<a name="__line395"></a>
<a name="__line396"></a>	check_args_ = f1.check_args_ || f2.check_args_;
<a name="__line397"></a>
<a name="__line398"></a>	if(!f1.derivatives_.empty() || !f2.derivatives_.empty())
<a name="__line399"></a>	{
<a name="__line400"></a>	    cerr&lt;&lt;"function::function(const function &amp;) does not yet copy the derivatives!"&lt;&lt;endl;
<a name="__line401"></a>	    cerr&lt;&lt;"Please strongly request the implementation of it by the author!!!"&lt;&lt;endl;
<a name="__line402"></a>	    exit(1);
<a name="__line403"></a>	}
<a name="__line404"></a>
<a name="__line405"></a>	{
<a name="__line406"></a>	    unsigned int i=0;
<a name="__line407"></a>	    for(; i&lt;f1.default_args_.size(); ++i) default_args_.push_back(f1.default_args_[i]);
<a name="__line408"></a>	    for(; i&lt;f2.default_args_.size(); ++i) default_args_.push_back(f2.default_args_[i]);
<a name="__line409"></a>	}
<a name="__line410"></a>	copy_arg_ranges_(f1,f2);
<a name="__line411"></a>    }
<a name="__line412"></a>
<a name="__line413"></a>    function::function(const function &amp;f1, const function &amp;f2, const function &amp;f3)
<a name="__line414"></a>    {
<a name="__line415"></a>	parnames_ = f1.parnames_;
<a name="__line416"></a>	for(unsigned int i=parnames_.size(); i&lt;f2.parnames_.size(); ++i)
<a name="__line417"></a>	    parnames_.push_back(f2.parnames_[i]);
<a name="__line418"></a>	for(unsigned int i=parnames_.size(); i&lt;f3.parnames_.size(); ++i)
<a name="__line419"></a>	    parnames_.push_back(f3.parnames_[i]);
<a name="__line420"></a>
<a name="__line421"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line422"></a>	base_ = m;
<a name="__line423"></a>	if(f1.initialized()) m-&gt;base_.push_back(f1.base_-&gt;clone());
<a name="__line424"></a>	if(f2.initialized()) m-&gt;base_.push_back(f2.base_-&gt;clone());
<a name="__line425"></a>	if(f3.initialized()) m-&gt;base_.push_back(f3.base_-&gt;clone());
<a name="__line426"></a>
<a name="__line427"></a>	print_param_value_ = false;
<a name="__line428"></a>	if(f1.print_param_value_ || f2.print_param_value_ || f3.print_param_value_)
<a name="__line429"></a>	    print_param_value_ = true;
<a name="__line430"></a>	{
<a name="__line431"></a>	    unsigned int i=0;
<a name="__line432"></a>	    for(; i&lt;f1.parameters_.size(); ++i) parameters_.push_back(f1.parameters_[i]);
<a name="__line433"></a>	    for(; i&lt;f2.parameters_.size(); ++i) parameters_.push_back(f2.parameters_[i]);
<a name="__line434"></a>	    for(; i&lt;f3.parameters_.size(); ++i) parameters_.push_back(f3.parameters_[i]);
<a name="__line435"></a>	}
<a name="__line436"></a>	init_();
<a name="__line437"></a>
<a name="__line438"></a>	check_args_ = f1.check_args_ || f2.check_args_ || f3.check_args_;
<a name="__line439"></a>
<a name="__line440"></a>	if(!f1.derivatives_.empty() || !f2.derivatives_.empty() || !f3.derivatives_.empty())
<a name="__line441"></a>	{
<a name="__line442"></a>	    cerr&lt;&lt;"function::function(const function &amp;) does not yet copy the derivatives!"&lt;&lt;endl;
<a name="__line443"></a>	    cerr&lt;&lt;"Please strongly request the implementation of it by the author!!!"&lt;&lt;endl;
<a name="__line444"></a>	    exit(1);
<a name="__line445"></a>	}
<a name="__line446"></a>
<a name="__line447"></a>	{
<a name="__line448"></a>	    unsigned int i=0;
<a name="__line449"></a>	    for(; i&lt;f1.default_args_.size(); ++i) default_args_.push_back(f1.default_args_[i]);
<a name="__line450"></a>	    for(; i&lt;f2.default_args_.size(); ++i) default_args_.push_back(f2.default_args_[i]);
<a name="__line451"></a>	    for(; i&lt;f3.default_args_.size(); ++i) default_args_.push_back(f3.default_args_[i]);
<a name="__line452"></a>	}
<a name="__line453"></a>
<a name="__line454"></a>	copy_arg_ranges_(f1,f2,f3);
<a name="__line455"></a>    }
<a name="__line456"></a>
<a name="__line457"></a>
<a name="__line458"></a>
<a name="__line459"></a>    function::function(const function &amp;f1, const function &amp;f2, const function &amp;f3, const function &amp;f4)
<a name="__line460"></a>    {
<a name="__line461"></a>	parnames_ = f1.parnames_;
<a name="__line462"></a>	for(unsigned int i=parnames_.size(); i&lt;f2.parnames_.size(); ++i)
<a name="__line463"></a>	    parnames_.push_back(f2.parnames_[i]);
<a name="__line464"></a>	for(unsigned int i=parnames_.size(); i&lt;f3.parnames_.size(); ++i)
<a name="__line465"></a>	    parnames_.push_back(f3.parnames_[i]);
<a name="__line466"></a>	for(unsigned int i=parnames_.size(); i&lt;f4.parnames_.size(); ++i)
<a name="__line467"></a>	    parnames_.push_back(f4.parnames_[i]);
<a name="__line468"></a>
<a name="__line469"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line470"></a>	base_ = m;
<a name="__line471"></a>	if(f1.initialized()) m-&gt;base_.push_back(f1.base_-&gt;clone());
<a name="__line472"></a>	if(f2.initialized()) m-&gt;base_.push_back(f2.base_-&gt;clone());
<a name="__line473"></a>	if(f3.initialized()) m-&gt;base_.push_back(f3.base_-&gt;clone());
<a name="__line474"></a>	if(f4.initialized()) m-&gt;base_.push_back(f4.base_-&gt;clone());
<a name="__line475"></a>
<a name="__line476"></a>	print_param_value_ = false;
<a name="__line477"></a>	if(f1.print_param_value_ ||
<a name="__line478"></a>	   f2.print_param_value_ ||
<a name="__line479"></a>	   f3.print_param_value_ ||
<a name="__line480"></a>	   f4.print_param_value_) print_param_value_ = true;
<a name="__line481"></a>	   
<a name="__line482"></a>	{
<a name="__line483"></a>	    unsigned int i=0;
<a name="__line484"></a>	    for(; i&lt;f1.parameters_.size(); ++i) parameters_.push_back(f1.parameters_[i]);
<a name="__line485"></a>	    for(; i&lt;f2.parameters_.size(); ++i) parameters_.push_back(f2.parameters_[i]);
<a name="__line486"></a>	    for(; i&lt;f3.parameters_.size(); ++i) parameters_.push_back(f3.parameters_[i]);
<a name="__line487"></a>	    for(; i&lt;f4.parameters_.size(); ++i) parameters_.push_back(f4.parameters_[i]);
<a name="__line488"></a>	}
<a name="__line489"></a>	init_();
<a name="__line490"></a>
<a name="__line491"></a>	check_args_ = f1.check_args_ || f2.check_args_ || f3.check_args_ || f4.check_args_;
<a name="__line492"></a>
<a name="__line493"></a>	if(!f1.derivatives_.empty() || !f2.derivatives_.empty() || !f3.derivatives_.empty() || !f4.derivatives_.empty())
<a name="__line494"></a>	{
<a name="__line495"></a>	    cerr&lt;&lt;"function::function(const function &amp;) does not yet copy the derivatives!"&lt;&lt;endl;
<a name="__line496"></a>	    cerr&lt;&lt;"Please strongly request the implementation of it by the author!!!"&lt;&lt;endl;
<a name="__line497"></a>	    exit(1);
<a name="__line498"></a>	}
<a name="__line499"></a>
<a name="__line500"></a>	{
<a name="__line501"></a>	    unsigned int i=0;
<a name="__line502"></a>	    for(; i&lt;f1.default_args_.size(); ++i) default_args_.push_back(f1.default_args_[i]);
<a name="__line503"></a>	    for(; i&lt;f2.default_args_.size(); ++i) default_args_.push_back(f2.default_args_[i]);
<a name="__line504"></a>	    for(; i&lt;f3.default_args_.size(); ++i) default_args_.push_back(f3.default_args_[i]);
<a name="__line505"></a>	    for(; i&lt;f4.default_args_.size(); ++i) default_args_.push_back(f4.default_args_[i]);
<a name="__line506"></a>	}
<a name="__line507"></a>
<a name="__line508"></a>	copy_arg_ranges_(f1,f2,f3,f4);
<a name="__line509"></a>    }
<a name="__line510"></a>
<a name="__line511"></a>    function::function(const function &amp;f1, const function &amp;f2, const function &amp;f3, const function &amp;f4, const function &amp;f5)
<a name="__line512"></a>    {
<a name="__line513"></a>	parnames_ = f1.parnames_;
<a name="__line514"></a>	for(unsigned int i=parnames_.size(); i&lt;f2.parnames_.size(); ++i)
<a name="__line515"></a>	    parnames_.push_back(f2.parnames_[i]);
<a name="__line516"></a>	for(unsigned int i=parnames_.size(); i&lt;f3.parnames_.size(); ++i)
<a name="__line517"></a>	    parnames_.push_back(f3.parnames_[i]);
<a name="__line518"></a>	for(unsigned int i=parnames_.size(); i&lt;f4.parnames_.size(); ++i)
<a name="__line519"></a>	    parnames_.push_back(f4.parnames_[i]);
<a name="__line520"></a>	for(unsigned int i=parnames_.size(); i&lt;f5.parnames_.size(); ++i)
<a name="__line521"></a>	    parnames_.push_back(f5.parnames_[i]);
<a name="__line522"></a>
<a name="__line523"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line524"></a>	base_ = m;
<a name="__line525"></a>	if(f1.initialized()) m-&gt;base_.push_back(f1.base_-&gt;clone());
<a name="__line526"></a>	if(f2.initialized()) m-&gt;base_.push_back(f2.base_-&gt;clone());
<a name="__line527"></a>	if(f3.initialized()) m-&gt;base_.push_back(f3.base_-&gt;clone());
<a name="__line528"></a>	if(f4.initialized()) m-&gt;base_.push_back(f4.base_-&gt;clone());
<a name="__line529"></a>	if(f5.initialized()) m-&gt;base_.push_back(f5.base_-&gt;clone());
<a name="__line530"></a>
<a name="__line531"></a>	print_param_value_ = false;
<a name="__line532"></a>	if(f1.print_param_value_ ||
<a name="__line533"></a>	   f2.print_param_value_ ||
<a name="__line534"></a>	   f3.print_param_value_ ||
<a name="__line535"></a>	   f4.print_param_value_ ||
<a name="__line536"></a>	   f5.print_param_value_ ) print_param_value_ = true;
<a name="__line537"></a>	   
<a name="__line538"></a>	{
<a name="__line539"></a>	    unsigned int i=0;
<a name="__line540"></a>	    for(; i&lt;f1.parameters_.size(); ++i) parameters_.push_back(f1.parameters_[i]);
<a name="__line541"></a>	    for(; i&lt;f2.parameters_.size(); ++i) parameters_.push_back(f2.parameters_[i]);
<a name="__line542"></a>	    for(; i&lt;f3.parameters_.size(); ++i) parameters_.push_back(f3.parameters_[i]);
<a name="__line543"></a>	    for(; i&lt;f4.parameters_.size(); ++i) parameters_.push_back(f4.parameters_[i]);
<a name="__line544"></a>	    for(; i&lt;f5.parameters_.size(); ++i) parameters_.push_back(f5.parameters_[i]);
<a name="__line545"></a>	}
<a name="__line546"></a>	init_();
<a name="__line547"></a>
<a name="__line548"></a>	check_args_ = f1.check_args_ || f2.check_args_ || f3.check_args_ || f4.check_args_ || f5.check_args_;
<a name="__line549"></a>
<a name="__line550"></a>	if(!f1.derivatives_.empty() || !f2.derivatives_.empty() || !f3.derivatives_.empty() || !f4.derivatives_.empty() || !f5.derivatives_.empty())
<a name="__line551"></a>	{
<a name="__line552"></a>	    cerr&lt;&lt;"function::function(const function &amp;) does not yet copy the derivatives!"&lt;&lt;endl;
<a name="__line553"></a>	    cerr&lt;&lt;"Please strongly request the implementation of it by the author!!!"&lt;&lt;endl;
<a name="__line554"></a>	    exit(1);
<a name="__line555"></a>	}
<a name="__line556"></a>
<a name="__line557"></a>	{
<a name="__line558"></a>	    unsigned int i=0;
<a name="__line559"></a>	    for(; i&lt;f1.default_args_.size(); ++i) default_args_.push_back(f1.default_args_[i]);
<a name="__line560"></a>	    for(; i&lt;f2.default_args_.size(); ++i) default_args_.push_back(f2.default_args_[i]);
<a name="__line561"></a>	    for(; i&lt;f3.default_args_.size(); ++i) default_args_.push_back(f3.default_args_[i]);
<a name="__line562"></a>	    for(; i&lt;f4.default_args_.size(); ++i) default_args_.push_back(f4.default_args_[i]);
<a name="__line563"></a>	    for(; i&lt;f5.default_args_.size(); ++i) default_args_.push_back(f5.default_args_[i]);
<a name="__line564"></a>	}
<a name="__line565"></a>
<a name="__line566"></a>	copy_arg_ranges_(f1,f2,f3,f4,f5);
<a name="__line567"></a>    }
<a name="__line568"></a>
<a name="__line569"></a>    function::function(const function &amp;f1, const function &amp;f2, const function &amp;f3, const function &amp;f4, const function &amp;f5, const function &amp;f6)
<a name="__line570"></a>    {
<a name="__line571"></a>	parnames_ = f1.parnames_;
<a name="__line572"></a>	for(unsigned int i=parnames_.size(); i&lt;f2.parnames_.size(); ++i)
<a name="__line573"></a>	    parnames_.push_back(f2.parnames_[i]);
<a name="__line574"></a>	for(unsigned int i=parnames_.size(); i&lt;f3.parnames_.size(); ++i)
<a name="__line575"></a>	    parnames_.push_back(f3.parnames_[i]);
<a name="__line576"></a>	for(unsigned int i=parnames_.size(); i&lt;f4.parnames_.size(); ++i)
<a name="__line577"></a>	    parnames_.push_back(f4.parnames_[i]);
<a name="__line578"></a>	for(unsigned int i=parnames_.size(); i&lt;f5.parnames_.size(); ++i)
<a name="__line579"></a>	    parnames_.push_back(f5.parnames_[i]);
<a name="__line580"></a>	for(unsigned int i=parnames_.size(); i&lt;f6.parnames_.size(); ++i)
<a name="__line581"></a>	    parnames_.push_back(f6.parnames_[i]);
<a name="__line582"></a>
<a name="__line583"></a>	function_core::multiple *m = new function_core::multiple;
<a name="__line584"></a>	base_ = m;
<a name="__line585"></a>	if(f1.initialized()) m-&gt;base_.push_back(f1.base_-&gt;clone());
<a name="__line586"></a>	if(f2.initialized()) m-&gt;base_.push_back(f2.base_-&gt;clone());
<a name="__line587"></a>	if(f3.initialized()) m-&gt;base_.push_back(f3.base_-&gt;clone());
<a name="__line588"></a>	if(f4.initialized()) m-&gt;base_.push_back(f4.base_-&gt;clone());
<a name="__line589"></a>	if(f5.initialized()) m-&gt;base_.push_back(f5.base_-&gt;clone());
<a name="__line590"></a>	if(f6.initialized()) m-&gt;base_.push_back(f6.base_-&gt;clone());
<a name="__line591"></a>
<a name="__line592"></a>	print_param_value_ = false;
<a name="__line593"></a>	if(f1.print_param_value_ ||
<a name="__line594"></a>	   f2.print_param_value_ ||
<a name="__line595"></a>	   f3.print_param_value_ ||
<a name="__line596"></a>	   f4.print_param_value_ ||
<a name="__line597"></a>	   f5.print_param_value_ ||
<a name="__line598"></a>	   f6.print_param_value_ ) print_param_value_ = true;
<a name="__line599"></a>	   
<a name="__line600"></a>	{
<a name="__line601"></a>	    unsigned int i=0;
<a name="__line602"></a>	    for(; i&lt;f1.parameters_.size(); ++i) parameters_.push_back(f1.parameters_[i]);
<a name="__line603"></a>	    for(; i&lt;f2.parameters_.size(); ++i) parameters_.push_back(f2.parameters_[i]);
<a name="__line604"></a>	    for(; i&lt;f3.parameters_.size(); ++i) parameters_.push_back(f3.parameters_[i]);
<a name="__line605"></a>	    for(; i&lt;f4.parameters_.size(); ++i) parameters_.push_back(f4.parameters_[i]);
<a name="__line606"></a>	    for(; i&lt;f5.parameters_.size(); ++i) parameters_.push_back(f5.parameters_[i]);
<a name="__line607"></a>	    for(; i&lt;f6.parameters_.size(); ++i) parameters_.push_back(f6.parameters_[i]);
<a name="__line608"></a>	}
<a name="__line609"></a>	init_();
<a name="__line610"></a>
<a name="__line611"></a>	check_args_ = f1.check_args_ || f2.check_args_ || f3.check_args_ || f4.check_args_ || f5.check_args_ || f6.check_args_;
<a name="__line612"></a>
<a name="__line613"></a>	if(!f1.derivatives_.empty() || !f2.derivatives_.empty() || !f3.derivatives_.empty() ||
<a name="__line614"></a>           !f4.derivatives_.empty() ||
<a name="__line615"></a>           !f5.derivatives_.empty() ||
<a name="__line616"></a>           !f6.derivatives_.empty())
<a name="__line617"></a>	{
<a name="__line618"></a>	    cerr&lt;&lt;"function::function(const function &amp;) does not yet copy the derivatives!"&lt;&lt;endl;
<a name="__line619"></a>	    cerr&lt;&lt;"Please strongly request the implementation of it by the author!!!"&lt;&lt;endl;
<a name="__line620"></a>	    exit(1);
<a name="__line621"></a>	}
<a name="__line622"></a>
<a name="__line623"></a>	{
<a name="__line624"></a>	    unsigned int i=0;
<a name="__line625"></a>	    for(; i&lt;f1.default_args_.size(); ++i) default_args_.push_back(f1.default_args_[i]);
<a name="__line626"></a>	    for(; i&lt;f2.default_args_.size(); ++i) default_args_.push_back(f2.default_args_[i]);
<a name="__line627"></a>	    for(; i&lt;f3.default_args_.size(); ++i) default_args_.push_back(f3.default_args_[i]);
<a name="__line628"></a>	    for(; i&lt;f4.default_args_.size(); ++i) default_args_.push_back(f4.default_args_[i]);
<a name="__line629"></a>	    for(; i&lt;f5.default_args_.size(); ++i) default_args_.push_back(f5.default_args_[i]);
<a name="__line630"></a>	    for(; i&lt;f6.default_args_.size(); ++i) default_args_.push_back(f6.default_args_[i]);
<a name="__line631"></a>	}
<a name="__line632"></a>
<a name="__line633"></a>	copy_arg_ranges_(f1,f2,f3,f4,f5,f6);
<a name="__line634"></a>    }
<a name="__line635"></a>
<a name="__line636"></a>
<a name="__line637"></a>
<a name="__line638"></a>    function::~function()
<a name="__line639"></a>    {
<a name="__line640"></a>	delete base_;
<a name="__line641"></a>	for(deriv_map::iterator iter=derivatives_.begin(); iter != derivatives_.end(); ++iter)
<a name="__line642"></a>	{
<a name="__line643"></a>	    delete (*iter).second;
<a name="__line644"></a>	}
<a name="__line645"></a>    }
<a name="__line646"></a>
<a name="__line647"></a>    <span class=comment>// ---------- Append more components ----------------------------------------------</span>
<a name="__line648"></a>
<a name="__line649"></a>    function &amp;function::append(const function &amp;f)
<a name="__line650"></a>    {
<a name="__line651"></a>	if(f.base_ == 0) return *this;
<a name="__line652"></a>
<a name="__line653"></a>	for(unsigned int i=parameters_.size(); i&lt;f.parameters_.size(); ++i) parameters_.push_back(f.parameters_[i]);
<a name="__line654"></a>
<a name="__line655"></a>	if(base_ == 0)
<a name="__line656"></a>	{
<a name="__line657"></a>	    base_ = f.base_-&gt;clone();
<a name="__line658"></a>	}
<a name="__line659"></a>	else if(function_core::multiple *m = dynamic_cast&lt;function_core::multiple*&gt;(base_))
<a name="__line660"></a>	{
<a name="__line661"></a>	    m-&gt;base_.push_back(f.base_-&gt;clone());
<a name="__line662"></a>	}
<a name="__line663"></a>	else
<a name="__line664"></a>	{
<a name="__line665"></a>	    function_core::multiple *m1 = new function_core::multiple;
<a name="__line666"></a>	    m1-&gt;base_.resize(2);
<a name="__line667"></a>	    m1-&gt;base_[0] = base_;
<a name="__line668"></a>	    m1-&gt;base_[1] = f.base_-&gt;clone();
<a name="__line669"></a>	    base_ = m1;
<a name="__line670"></a>	}
<a name="__line671"></a>
<a name="__line672"></a>	if(!f.derivatives_.empty() || !derivatives_.empty())
<a name="__line673"></a>	{
<a name="__line674"></a>	    cerr&lt;&lt;"function::append does not correctly handle the user-set derivatives"&lt;&lt;endl;
<a name="__line675"></a>	    cerr&lt;&lt;"Strongly request this feature from the author"&lt;&lt;endl;
<a name="__line676"></a>	    cerr&lt;&lt;"Set the derivatives now after the call to function::append(...)"&lt;&lt;endl;
<a name="__line677"></a>	}
<a name="__line678"></a>
<a name="__line679"></a>	init_();
<a name="__line680"></a>	return *this;
<a name="__line681"></a>    }
<a name="__line682"></a>
<a name="__line683"></a>    <span class=comment>// ---------- get/set parameter values  -------------------------------------------</span>
<a name="__line684"></a>
<a name="__line685"></a>    function &amp;function::parformat(unsigned int parindex, const var &amp;format)
<a name="__line686"></a>    {
<a name="__line687"></a>	if(parindex==0)
<a name="__line688"></a>	{
<a name="__line689"></a>	    for(unsigned int i=0; i&lt;parameters_.size(); ++i) parameters_[i].format(format);
<a name="__line690"></a>	}
<a name="__line691"></a>	else
<a name="__line692"></a>	{
<a name="__line693"></a>	    if(parindex &gt; parameters_.size()) parameters_.resize(parindex);
<a name="__line694"></a>	    parameters_[parindex-1].format(format);
<a name="__line695"></a>	}
<a name="__line696"></a>	return *this;
<a name="__line697"></a>    }
<a name="__line698"></a>
<a name="__line699"></a>    <span class=comment>/*
<a name="__line700"></a>      // already implemented as parformat
<a name="__line701"></a>    function &amp;function::param_format(const var &amp;fmt)
<a name="__line702"></a>    {
<a name="__line703"></a>        for(unsigned int i=0; i&lt;parameters_.size(); ++i) parameters_[i].format(fmt);
<a name="__line704"></a>        return *this;
<a name="__line705"></a>    }
<a name="__line706"></a>    */</span>
<a name="__line707"></a>
<a name="__line708"></a>    const var &amp;function::param(unsigned int i) const
<a name="__line709"></a>    {
<a name="__line710"></a>	--i;
<a name="__line711"></a>	if(i&lt;0 || parameters_.size()&lt;=i)
<a name="__line712"></a>	{
<a name="__line713"></a>	    static var dummy;
<a name="__line714"></a>	    return dummy;
<a name="__line715"></a>	}
<a name="__line716"></a>	return parameters_[i];
<a name="__line717"></a>    }
<a name="__line718"></a>
<a name="__line719"></a>    var &amp;function::param(unsigned int i)
<a name="__line720"></a>    {
<a name="__line721"></a>	--i;
<a name="__line722"></a>	if(i&lt;0 || parameters_.size()&lt;=i)
<a name="__line723"></a>	{
<a name="__line724"></a>	    static var dummy;
<a name="__line725"></a>	    return dummy;
<a name="__line726"></a>	}
<a name="__line727"></a>	return parameters_[i];
<a name="__line728"></a>    }
<a name="__line729"></a>
<a name="__line730"></a>    function &amp;function::params(double p1,
<a name="__line731"></a>			       double p2,
<a name="__line732"></a>			       double p3,
<a name="__line733"></a>			       double p4,
<a name="__line734"></a>			       double p5,
<a name="__line735"></a>			       double p6)
<a name="__line736"></a>    {
<a name="__line737"></a>	param(1,p1);
<a name="__line738"></a>	param(2,p2);
<a name="__line739"></a>	if(p3!=unset) param(3,p3);
<a name="__line740"></a>	if(p4!=unset) param(4,p4);
<a name="__line741"></a>	if(p5!=unset) param(5,p5);
<a name="__line742"></a>	if(p6!=unset) param(6,p6);
<a name="__line743"></a>	return *this;
<a name="__line744"></a>    }
<a name="__line745"></a>
<a name="__line746"></a>    function &amp;function::params(const std::vector&lt;blop::var&gt; &amp;p)
<a name="__line747"></a>    {
<a name="__line748"></a>        parameters_ = p;
<a name="__line749"></a>        return *this;
<a name="__line750"></a>    }
<a name="__line751"></a>    function &amp;function::params(const std::vector&lt;double&gt; &amp;p)
<a name="__line752"></a>    {
<a name="__line753"></a>        parameters_.resize(p.size());
<a name="__line754"></a>        for(unsigned int i=0; i&lt;p.size(); ++i) parameters_[i] = p[i];
<a name="__line755"></a>        return *this;
<a name="__line756"></a>    }
<a name="__line757"></a>
<a name="__line758"></a>    function &amp;function::param(unsigned int i, const var &amp;value)
<a name="__line759"></a>    {
<a name="__line760"></a>	if(i&lt;1)
<a name="__line761"></a>	{
<a name="__line762"></a>	    warning::print("Parameter index &lt; 1",
<a name="__line763"></a>			   "function::param(int parindex, const var &amp;value)");
<a name="__line764"></a>	    return *this;
<a name="__line765"></a>	}
<a name="__line766"></a>	--i;
<a name="__line767"></a>	if(i &gt;= parameters_.size())  parameters_.resize(i+1);
<a name="__line768"></a>	parameters_[i] = value;
<a name="__line769"></a>	return *this;
<a name="__line770"></a>    }
<a name="__line771"></a>
<a name="__line772"></a>    function &amp;function::param(unsigned int i, double value)
<a name="__line773"></a>    {
<a name="__line774"></a>	if(i&lt;1)
<a name="__line775"></a>	{
<a name="__line776"></a>	    warning::print("Parameter index &lt; 1",
<a name="__line777"></a>			   "function::param(int parindex, const var &amp;value)");
<a name="__line778"></a>	    return *this;
<a name="__line779"></a>	}
<a name="__line780"></a>	--i;
<a name="__line781"></a>	if(i &gt;= parameters_.size())  parameters_.resize(i+1);
<a name="__line782"></a>	parameters_[i] = value;
<a name="__line783"></a>	return *this;
<a name="__line784"></a>    }
<a name="__line785"></a>
<a name="__line786"></a>    function &amp;function::param(const function &amp;p, var value)
<a name="__line787"></a>    {
<a name="__line788"></a>        function_core::funcparameter *P = dynamic_cast&lt;function_core::funcparameter*&gt;(p.base_);
<a name="__line789"></a>        if(!P)
<a name="__line790"></a>        {
<a name="__line791"></a>            warning::print("The provided argument 'p' is not a pure function parameter function","function::param(const function &amp;p, var value)");
<a name="__line792"></a>            return *this;
<a name="__line793"></a>        }
<a name="__line794"></a>
<a name="__line795"></a>        <span class=comment>// a simple funcparameter returns npars() which is equal to the parameter index (1-based)</span>
<a name="__line796"></a>        int i = P-&gt;npars();
<a name="__line797"></a>	if(i&lt;1)
<a name="__line798"></a>	{
<a name="__line799"></a>	    warning::print("Parameter index &lt; 1",
<a name="__line800"></a>			   "function::param(int parindex, const var &amp;value)");
<a name="__line801"></a>	    return *this;
<a name="__line802"></a>	}
<a name="__line803"></a>	--i;
<a name="__line804"></a>	if(i &gt;= (int)parameters_.size())  parameters_.resize(i+1);
<a name="__line805"></a>	parameters_[i] = value;
<a name="__line806"></a>	return *this;
<a name="__line807"></a>    }
<a name="__line808"></a>
<a name="__line809"></a>    function &amp;function::param(const function &amp;p, const var &amp;value, const var &amp;name)
<a name="__line810"></a>    {
<a name="__line811"></a>        function_core::funcparameter *P = dynamic_cast&lt;function_core::funcparameter*&gt;(p.base_);
<a name="__line812"></a>        if(!P)
<a name="__line813"></a>        {
<a name="__line814"></a>            warning::print("The provided argument 'p' is not a pure function parameter function","function::param(const function &amp;p, var value)");
<a name="__line815"></a>            return *this;
<a name="__line816"></a>        }
<a name="__line817"></a>
<a name="__line818"></a>        <span class=comment>// a simple funcparameter returns npars() which is equal to the parameter index (1-based)</span>
<a name="__line819"></a>        int i = P-&gt;npars();
<a name="__line820"></a>	if(i&lt;1)
<a name="__line821"></a>	{
<a name="__line822"></a>	    warning::print("Parameter index &lt; 1",
<a name="__line823"></a>			   "function::param(int parindex, const var &amp;value)");
<a name="__line824"></a>	    return *this;
<a name="__line825"></a>	}
<a name="__line826"></a>	--i;
<a name="__line827"></a>	if(i &gt;= (int)parameters_.size())  parameters_.resize(i+1);
<a name="__line828"></a>	parameters_[i] = value;
<a name="__line829"></a>        if(i &gt;= (int)parnames_.size()) parnames_.resize(i+1);
<a name="__line830"></a>        parnames_[i] = name;
<a name="__line831"></a>        return *this;
<a name="__line832"></a>    }
<a name="__line833"></a>
<a name="__line834"></a>
<a name="__line835"></a>    function &amp;function::param(unsigned int i, const var &amp;value, const var &amp;name)
<a name="__line836"></a>    {
<a name="__line837"></a>	param(i,value);
<a name="__line838"></a>	parname(i,name);
<a name="__line839"></a>	return *this;
<a name="__line840"></a>    }
<a name="__line841"></a>    function &amp;function::param(unsigned int i, double value, const var &amp;name)
<a name="__line842"></a>    {
<a name="__line843"></a>	param(i,value);
<a name="__line844"></a>	parname(i,name);
<a name="__line845"></a>	return *this;
<a name="__line846"></a>    }
<a name="__line847"></a>
<a name="__line848"></a>    const var &amp;function::param(const function &amp;p) const
<a name="__line849"></a>    {
<a name="__line850"></a>        static var dummy;
<a name="__line851"></a>
<a name="__line852"></a>        function_core::funcparameter *P = dynamic_cast&lt;function_core::funcparameter*&gt;(p.base_);
<a name="__line853"></a>        if(!P)
<a name="__line854"></a>        {
<a name="__line855"></a>            warning::print("The provided argument 'p' is not a pure function parameter function","function::param(const function &amp;p, var value)");
<a name="__line856"></a>            return dummy;
<a name="__line857"></a>        }
<a name="__line858"></a>
<a name="__line859"></a>        <span class=comment>// a simple funcparameter returns npars() which is equal to the parameter index (1-based)</span>
<a name="__line860"></a>        int i = P-&gt;npars()-1;
<a name="__line861"></a>        if(i&lt;0 || (int)parameters_.size()&lt;=i)
<a name="__line862"></a>        {
<a name="__line863"></a>            warning::print("Parameter index out of range","function::param(const function &amp;p)");
<a name="__line864"></a>            return dummy;
<a name="__line865"></a>        }
<a name="__line866"></a>	return parameters_[i];
<a name="__line867"></a>    }
<a name="__line868"></a>
<a name="__line869"></a>    var &amp;function::param(const function &amp;p) 
<a name="__line870"></a>    {
<a name="__line871"></a>        static var dummy;
<a name="__line872"></a>
<a name="__line873"></a>        function_core::funcparameter *P = dynamic_cast&lt;function_core::funcparameter*&gt;(p.base_);
<a name="__line874"></a>        if(!P)
<a name="__line875"></a>        {
<a name="__line876"></a>            warning::print("The provided argument 'p' is not a pure function parameter function","function::param(const function &amp;p, var value)");
<a name="__line877"></a>            return dummy;
<a name="__line878"></a>        }
<a name="__line879"></a>
<a name="__line880"></a>        <span class=comment>// a simple funcparameter returns npars() which is equal to the parameter index (1-based)</span>
<a name="__line881"></a>        int i = P-&gt;npars()-1;
<a name="__line882"></a>        if(i&lt;0 || (int)parameters_.size()&lt;=i)
<a name="__line883"></a>        {
<a name="__line884"></a>            warning::print("Parameter index out of range","function::param(const function &amp;p)");
<a name="__line885"></a>            return dummy;
<a name="__line886"></a>        }
<a name="__line887"></a>	return parameters_[i];
<a name="__line888"></a>    }
<a name="__line889"></a>
<a name="__line890"></a>    function &amp;function::parname(unsigned int i, const var &amp;name)
<a name="__line891"></a>    {
<a name="__line892"></a>	if(i&lt;1) return *this;
<a name="__line893"></a>	--i;
<a name="__line894"></a>	if(i&gt;=parnames_.size()) parnames_.resize(i+1);
<a name="__line895"></a>	parnames_[i] = name;
<a name="__line896"></a>	return *this;
<a name="__line897"></a>    }
<a name="__line898"></a>    var function::parname(unsigned int i)
<a name="__line899"></a>    {
<a name="__line900"></a>	if(i&lt;1 || parnames_.size()&lt;i) return var("parameter[") &amp; var(i) &amp; var("]");
<a name="__line901"></a>	return parnames_[i-1];
<a name="__line902"></a>    }
<a name="__line903"></a>
<a name="__line904"></a>
<a name="__line905"></a>    <span class=comment>// ---------- set default arguments -----------------------------------------------</span>
<a name="__line906"></a>
<a name="__line907"></a>    function &amp;function::def_arg(int arg_index, const var &amp;value)
<a name="__line908"></a>    {
<a name="__line909"></a>	if(--arg_index &gt;= (int)default_args_.size()) default_args_.resize(arg_index+1);
<a name="__line910"></a>	default_args_[arg_index] = value;
<a name="__line911"></a>	return  *this;
<a name="__line912"></a>    }
<a name="__line913"></a>    var function::def_arg(int arg_index) const
<a name="__line914"></a>    {
<a name="__line915"></a>	--arg_index;
<a name="__line916"></a>	if(arg_index &lt; 0) return "";
<a name="__line917"></a>	if(arg_index &gt;=(int)default_args_.size()) return "";
<a name="__line918"></a>	return default_args_[arg_index];
<a name="__line919"></a>    }
<a name="__line920"></a>
<a name="__line921"></a>    function &amp;function::clear_def_args()
<a name="__line922"></a>    {
<a name="__line923"></a>	default_args_.clear();
<a name="__line924"></a>	return *this;
<a name="__line925"></a>    }
<a name="__line926"></a>
<a name="__line927"></a>
<a name="__line928"></a>    <span class=comment>// ---------- query of required number of args/pars -------------------------------</span>
<a name="__line929"></a>
<a name="__line930"></a>    int function::nargs() const
<a name="__line931"></a>    {
<a name="__line932"></a>	if(!base_)
<a name="__line933"></a>	{
<a name="__line934"></a>	    warning::print("Uninitialized function","function::nargs()");
<a name="__line935"></a>	    return 0;
<a name="__line936"></a>	}
<a name="__line937"></a>	return base_-&gt;nargs();
<a name="__line938"></a>    }
<a name="__line939"></a>
<a name="__line940"></a>    int function::npars() const
<a name="__line941"></a>    {
<a name="__line942"></a>	if(!base_)
<a name="__line943"></a>	{
<a name="__line944"></a>	    warning::print("Uninitialized function","function::npars()");
<a name="__line945"></a>	    return 0;
<a name="__line946"></a>	}
<a name="__line947"></a>	return base_-&gt;npars();
<a name="__line948"></a>    }
<a name="__line949"></a>
<a name="__line950"></a>    function function::create_narg()
<a name="__line951"></a>    {
<a name="__line952"></a>	return actual_nargs();
<a name="__line953"></a>    }
<a name="__line954"></a>
<a name="__line955"></a>    bool function::make_arg_check_(const std::vector&lt;blop::var&gt; &amp;args) const
<a name="__line956"></a>    {
<a name="__line957"></a>	if(arg_min_.empty() &amp;&amp; arg_max_.empty()) return true;
<a name="__line958"></a>	bool result = true;
<a name="__line959"></a>	for(unsigned int i=0; i&lt;args.size(); ++i)
<a name="__line960"></a>	{
<a name="__line961"></a>	    bool this_arg_ok = true;
<a name="__line962"></a>	    const double min = (i&lt;arg_min_.size() ? arg_min_[i] : unset);
<a name="__line963"></a>	    if(min != unset &amp;&amp; args[i].dbl() &lt; min) this_arg_ok = false;
<a name="__line964"></a>	    const double max = (i&lt;arg_max_.size() ? arg_max_[i] : unset);
<a name="__line965"></a>	    if(max != unset &amp;&amp; args[i].dbl() &gt; max) this_arg_ok = false;
<a name="__line966"></a>	    if(!this_arg_ok)
<a name="__line967"></a>	    {
<a name="__line968"></a>		result = false;
<a name="__line969"></a>		char argvalue[100];
<a name="__line970"></a>		sprintf(argvalue,"%.15f",args[i].dbl());
<a name="__line971"></a>		char minvalue[100], maxvalue[100];
<a name="__line972"></a>		sprintf(minvalue,"%.15f",min);
<a name="__line973"></a>		sprintf(maxvalue,"%.15f",max);
<a name="__line974"></a>		warning::print("Function argument #" &amp; var(i+1) &amp;
<a name="__line975"></a>			       var("=") &amp; argvalue &amp; var(" is out of range [") &amp;
<a name="__line976"></a>			       minvalue &amp; var(";") &amp; maxvalue &amp; var("]"),
<a name="__line977"></a>			       "function::make_arg_check_(...)");
<a name="__line978"></a>	    }
<a name="__line979"></a>	}
<a name="__line980"></a>	return result;
<a name="__line981"></a>    }
<a name="__line982"></a>
<a name="__line983"></a>    function &amp;function::check_args(bool flag)
<a name="__line984"></a>    {
<a name="__line985"></a>	check_args_ = flag;
<a name="__line986"></a>	return *this;
<a name="__line987"></a>    }
<a name="__line988"></a>
<a name="__line989"></a>    void function::default_check_args(bool flag)
<a name="__line990"></a>    {
<a name="__line991"></a>	default_check_args_ = flag;
<a name="__line992"></a>    }
<a name="__line993"></a>	 
<a name="__line994"></a>
<a name="__line995"></a>    function &amp;function::arg_min(int arg_no, double value)
<a name="__line996"></a>    {
<a name="__line997"></a>	if(arg_no&lt;1 || !uses_arg(arg_no))
<a name="__line998"></a>	{
<a name="__line999"></a>	    warning::print(var("Argument ") &amp; var(arg_no) &amp; var(" is not used"),
<a name="__line1000"></a>			   "function::arg_min(int arg_no, double value)");
<a name="__line1001"></a>	    return *this;
<a name="__line1002"></a>	}
<a name="__line1003"></a>	--arg_no;
<a name="__line1004"></a>	if((unsigned int)arg_no &gt;= arg_min_.size()) arg_min_.resize(arg_no+1,unset);
<a name="__line1005"></a>	arg_min_[arg_no] = value;
<a name="__line1006"></a>	return *this;
<a name="__line1007"></a>    }
<a name="__line1008"></a>
<a name="__line1009"></a>    function &amp;function::arg_max(int arg_no, double value)
<a name="__line1010"></a>    {
<a name="__line1011"></a>	if(arg_no&lt;1 || !uses_arg(arg_no))
<a name="__line1012"></a>	{
<a name="__line1013"></a>	    warning::print(var("Argument ") &amp; var(arg_no) &amp; var(" is not used"),
<a name="__line1014"></a>			   "function::arg_max(int arg_no, double value)");
<a name="__line1015"></a>	    return *this;
<a name="__line1016"></a>	}
<a name="__line1017"></a>	--arg_no;
<a name="__line1018"></a>	if((unsigned int)arg_no &gt;= arg_max_.size()) arg_max_.resize(arg_no+1,unset);
<a name="__line1019"></a>	arg_max_[arg_no] = value;
<a name="__line1020"></a>	return *this;
<a name="__line1021"></a>    }
<a name="__line1022"></a>
<a name="__line1023"></a>    function &amp;function::arg_range(int arg_no, double min, double max)
<a name="__line1024"></a>    {
<a name="__line1025"></a>	arg_min(arg_no, min);
<a name="__line1026"></a>	arg_max(arg_no, max);
<a name="__line1027"></a>	return *this;
<a name="__line1028"></a>    }
<a name="__line1029"></a>
<a name="__line1030"></a>    double function::arg_min(int arg_no)
<a name="__line1031"></a>    {
<a name="__line1032"></a>	--arg_no;
<a name="__line1033"></a>	if(arg_no&lt;0 || (int)arg_min_.size() &lt;= arg_no) return unset;
<a name="__line1034"></a>	return arg_min_[arg_no];
<a name="__line1035"></a>    }
<a name="__line1036"></a>
<a name="__line1037"></a>    double function::arg_max(int arg_no)
<a name="__line1038"></a>    {
<a name="__line1039"></a>	--arg_no;
<a name="__line1040"></a>	if(arg_no&lt;0 || (int)arg_max_.size() &lt;= arg_no) return unset;
<a name="__line1041"></a>	return arg_max_[arg_no];
<a name="__line1042"></a>    }
<a name="__line1043"></a>
<a name="__line1044"></a>    bool function::uses_arg(int argno) const
<a name="__line1045"></a>    {
<a name="__line1046"></a>	if(!base_)
<a name="__line1047"></a>	{
<a name="__line1048"></a>	    warning::print("Uninitialized function","function::uses_arg(int)");
<a name="__line1049"></a>	    return false;
<a name="__line1050"></a>	}
<a name="__line1051"></a>	return base_-&gt;uses_arg(argno);
<a name="__line1052"></a>    }
<a name="__line1053"></a>
<a name="__line1054"></a>    bool function::uses_par(int parno) const
<a name="__line1055"></a>    {
<a name="__line1056"></a>	if(!base_)
<a name="__line1057"></a>	{
<a name="__line1058"></a>	    warning::print("Uninitialized function","function::uses_par(int)");
<a name="__line1059"></a>	    return 0;
<a name="__line1060"></a>	}
<a name="__line1061"></a>	return base_-&gt;uses_par(parno);
<a name="__line1062"></a>    }
<a name="__line1063"></a>
<a name="__line1064"></a>
<a name="__line1065"></a>    <span class=comment>// ---------- print the function --------------------------------------------------</span>
<a name="__line1066"></a>    var function::sprint() const
<a name="__line1067"></a>    {
<a name="__line1068"></a>	if(!base_)
<a name="__line1069"></a>	{
<a name="__line1070"></a>	    warning::print("Uninitialized function","function::sprint()");
<a name="__line1071"></a>	    return "";
<a name="__line1072"></a>	}
<a name="__line1073"></a>	string result = base_-&gt;sprint(parameters_,print_param_value_);
<a name="__line1074"></a>	if(base_-&gt;n_out()&gt;1) result = "[" + result + "]";
<a name="__line1075"></a>	return result;
<a name="__line1076"></a>    }
<a name="__line1077"></a>    var function::sprint(std::map&lt;int,blop::var&gt; variable_names, std::map&lt;int,blop::var&gt; param_names) const
<a name="__line1078"></a>    {
<a name="__line1079"></a>	if(!base_)
<a name="__line1080"></a>	{
<a name="__line1081"></a>	    warning::print("Uninitialized function","function::sprint()");
<a name="__line1082"></a>	    return "";
<a name="__line1083"></a>	}
<a name="__line1084"></a>	string result = base_-&gt;sprint(parameters_,print_param_value_,variable_names,param_names);
<a name="__line1085"></a>	if(base_-&gt;n_out()&gt;1) result = "[" + result + "]";
<a name="__line1086"></a>	return result;
<a name="__line1087"></a>    }
<a name="__line1088"></a>
<a name="__line1089"></a>    var function::sprint_latex(const var &amp;x, const var &amp;y, const var &amp;z) const
<a name="__line1090"></a>    {
<a name="__line1091"></a>	if(!base_)
<a name="__line1092"></a>	{
<a name="__line1093"></a>	    warning::print("Uninitialized function","function::sprint_latex(...)");
<a name="__line1094"></a>	    return "";
<a name="__line1095"></a>	}
<a name="__line1096"></a>	var result = base_-&gt;sprint_latex(parameters_,print_param_value_,x,y,z);
<a name="__line1097"></a>	if(base_-&gt;n_out()&gt;1) result = var("\\left[") &amp; result &amp; var("\\right]");
<a name="__line1098"></a>	result = var("$") &amp; result &amp; var("$");
<a name="__line1099"></a>	return result;
<a name="__line1100"></a>    }
<a name="__line1101"></a>
<a name="__line1102"></a>    void function::print(std::ostream &amp;out) const { out&lt;&lt;sprint(); }
<a name="__line1103"></a>
<a name="__line1104"></a>    function function::operator[] (unsigned int comp) const
<a name="__line1105"></a>    {
<a name="__line1106"></a>	if(!base_) return 0.0;
<a name="__line1107"></a>
<a name="__line1108"></a>	if((int)comp &gt;= base_-&gt;n_out())
<a name="__line1109"></a>	{
<a name="__line1110"></a>	    warning::print("Index out of range",var("function::operator[](") &amp; var(comp) &amp; var(")"));
<a name="__line1111"></a>	    return 0.0;
<a name="__line1112"></a>	}
<a name="__line1113"></a>
<a name="__line1114"></a>	if(base_-&gt;n_out() == 1)
<a name="__line1115"></a>	{
<a name="__line1116"></a>	    function result(base_-&gt;clone());
<a name="__line1117"></a>	    result.parameters_ = parameters_;
<a name="__line1118"></a>	    result.print_param_value_ = print_param_value_;
<a name="__line1119"></a>	    result.default_args_ = default_args_;
<a name="__line1120"></a>	    result.parnames_ = parnames_;
<a name="__line1121"></a>	    return result;
<a name="__line1122"></a>	}
<a name="__line1123"></a>
<a name="__line1124"></a>	function result(new function_core::component(*base_,comp));
<a name="__line1125"></a>	result.parameters_ = parameters_;
<a name="__line1126"></a>	result.print_param_value_ = print_param_value_;
<a name="__line1127"></a>	result.default_args_ = default_args_;
<a name="__line1128"></a>	result.parnames_ = parnames_;
<a name="__line1129"></a>	return result;
<a name="__line1130"></a>    }
<a name="__line1131"></a>
<a name="__line1132"></a>    double function::eval_meas_error(const std::vector&lt;blop::var&gt; &amp;vals, const std::vector&lt;blop::var&gt; &amp;errors) const
<a name="__line1133"></a>    {
<a name="__line1134"></a>	double result = 0;
<a name="__line1135"></a>	for(unsigned int i=0; i&lt;vals.size(); ++i)
<a name="__line1136"></a>	{
<a name="__line1137"></a>	    function deriv = derivative(i+1);
<a name="__line1138"></a>	    const double d = deriv.eval_dbl(vals);
<a name="__line1139"></a>	    result += d*d*errors[i].dbl()*errors[i].dbl();
<a name="__line1140"></a>	}
<a name="__line1141"></a>	return ::sqrt(result);
<a name="__line1142"></a>    }
<a name="__line1143"></a>
<a name="__line1144"></a>    meas function::operator()(const meas &amp;x1) const
<a name="__line1145"></a>    {
<a name="__line1146"></a>	vector&lt;var&gt; vals(1), errs(1);
<a name="__line1147"></a>	vals[0].dbl() = x1.value();
<a name="__line1148"></a>	errs[0].dbl() = x1.error();
<a name="__line1149"></a>	return meas(eval(vals),eval_meas_error(vals,errs));
<a name="__line1150"></a>    }
<a name="__line1151"></a>    meas function::operator()(const meas &amp;x1, const meas &amp;x2) const
<a name="__line1152"></a>    {
<a name="__line1153"></a>	vector&lt;var&gt; vals(2), errs(2);
<a name="__line1154"></a>	vals[0].dbl() = x1.value();
<a name="__line1155"></a>	errs[0].dbl() = x1.error();
<a name="__line1156"></a>	vals[1].dbl() = x2.value();
<a name="__line1157"></a>	errs[1].dbl() = x2.error();
<a name="__line1158"></a>	return meas(eval(vals),eval_meas_error(vals,errs));
<a name="__line1159"></a>    }
<a name="__line1160"></a>    meas function::operator()(const meas &amp;x1, const meas &amp;x2, const meas &amp;x3) const
<a name="__line1161"></a>    {
<a name="__line1162"></a>	vector&lt;var&gt; vals(3), errs(3);
<a name="__line1163"></a>	vals[0].dbl() = x1.value();
<a name="__line1164"></a>	errs[0].dbl() = x1.error();
<a name="__line1165"></a>	vals[1].dbl() = x2.value();
<a name="__line1166"></a>	errs[1].dbl() = x2.error();
<a name="__line1167"></a>	vals[2].dbl() = x3.value();
<a name="__line1168"></a>	errs[2].dbl() = x3.error();
<a name="__line1169"></a>	return meas(eval(vals),eval_meas_error(vals,errs));
<a name="__line1170"></a>    }
<a name="__line1171"></a>    meas function::operator()(const meas &amp;x1, const meas &amp;x2, const meas &amp;x3, const meas &amp;x4) const
<a name="__line1172"></a>    {
<a name="__line1173"></a>	vector&lt;var&gt; vals(4), errs(4);
<a name="__line1174"></a>	vals[0].dbl() = x1.value();
<a name="__line1175"></a>	errs[0].dbl() = x1.error();
<a name="__line1176"></a>	vals[1].dbl() = x2.value();
<a name="__line1177"></a>	errs[1].dbl() = x2.error();
<a name="__line1178"></a>	vals[2].dbl() = x3.value();
<a name="__line1179"></a>	errs[2].dbl() = x3.error();
<a name="__line1180"></a>	vals[3].dbl() = x4.value();
<a name="__line1181"></a>	errs[3].dbl() = x4.error();
<a name="__line1182"></a>	return meas(eval(vals),eval_meas_error(vals,errs));
<a name="__line1183"></a>    }
<a name="__line1184"></a>
<a name="__line1185"></a>    <span class=comment>// the parenthesis operator, called with functions as arguments,</span>
<a name="__line1186"></a>    <span class=comment>// creates another function, with substituted arguments</span>
<a name="__line1187"></a>    function function::operator() (const function &amp;a1) const
<a name="__line1188"></a>    {
<a name="__line1189"></a>	if(a1.is_constant() &amp;&amp; npars()==0)
<a name="__line1190"></a>	{
<a name="__line1191"></a>	    if(a1.nargs() &gt; 0) warning::print("a1 claims to be constant, but has arguments");
<a name="__line1192"></a>	    std::vector&lt;blop::var&gt; args;
<a name="__line1193"></a>	    std::vector&lt;blop::var&gt; r1;
<a name="__line1194"></a>	    std::vector&lt;blop::var&gt; r2;
<a name="__line1195"></a>	    a1.meval(args, r1);
<a name="__line1196"></a>	    meval(r1,r2);
<a name="__line1197"></a>	    return r2;
<a name="__line1198"></a>	}
<a name="__line1199"></a>
<a name="__line1200"></a>	if(!a1.base_) return unset;
<a name="__line1201"></a>	function result(unset);
<a name="__line1202"></a>	result.print_param_value_ = print_param_value_;
<a name="__line1203"></a>	result.base_ = new function_core::argument_subst(base_, a1.base_);
<a name="__line1204"></a>	result.init_();
<a name="__line1205"></a>	if(parameters_.size() &gt; result.parameters_.size()) result.parameters_.resize(parameters_.size());
<a name="__line1206"></a>	for(unsigned int i=0; i&lt;parameters_.size(); ++i) result.parameters_[i] = parameters_[i];
<a name="__line1207"></a>	for(unsigned int i=result.parameters_.size(); i&lt;a1.parameters_.size(); ++i)
<a name="__line1208"></a>	    result.parameters_.push_back(a1.parameters_[i]);
<a name="__line1209"></a>	result.default_args_ = default_args_;
<a name="__line1210"></a>	return result;
<a name="__line1211"></a>    }
<a name="__line1212"></a>    function function::operator() (const function &amp;a1,const function &amp;a2) const
<a name="__line1213"></a>    {
<a name="__line1214"></a>	return operator()(function(a1,a2));
<a name="__line1215"></a>    }
<a name="__line1216"></a>    function function::operator() (const function &amp;a1,const function &amp;a2,const function &amp;a3) const
<a name="__line1217"></a>    {
<a name="__line1218"></a>	return operator()(function(a1,a2,a3));
<a name="__line1219"></a>    }
<a name="__line1220"></a>    function function::operator() (const function &amp;a1,const function &amp;a2,const function &amp;a3,const function &amp;a4) const
<a name="__line1221"></a>    {
<a name="__line1222"></a>	return operator()(function(a1,a2,a3,a4));
<a name="__line1223"></a>    }
<a name="__line1224"></a>    function function::operator() (const function &amp;a1,const function &amp;a2,const function &amp;a3,const function &amp;a4,const function &amp;a5) const
<a name="__line1225"></a>    {
<a name="__line1226"></a>	return operator()(function(a1,a2,a3,a4,a5));
<a name="__line1227"></a>    }
<a name="__line1228"></a>
<a name="__line1229"></a>    <span class=comment>// ---------- function evaluation -------------------------------------------------</span>
<a name="__line1230"></a>    var function::eval(const vector&lt;var&gt; &amp;args) const
<a name="__line1231"></a>    {
<a name="__line1232"></a>	if(check_args_) make_arg_check_(args);
<a name="__line1233"></a>	
<a name="__line1234"></a>	if(!base_)
<a name="__line1235"></a>	{
<a name="__line1236"></a>	    warning::print("Uninitialized function is being evaluated","function::eval(...)");
<a name="__line1237"></a>	    return 0;
<a name="__line1238"></a>	}
<a name="__line1239"></a>	int dummy = 0;
<a name="__line1240"></a>	base_-&gt;eval(args, default_args_, parameters_, result_, &amp;dummy);
<a name="__line1241"></a>	return result_[0];
<a name="__line1242"></a>    }
<a name="__line1243"></a>
<a name="__line1244"></a>    double function::eval_dbl(const std::vector&lt;blop::var&gt; &amp;args, const std::vector&lt;blop::var&gt; &amp;pars) const
<a name="__line1245"></a>    {
<a name="__line1246"></a>	if(!base_)
<a name="__line1247"></a>	{
<a name="__line1248"></a>	    warning::print("Uninitialized function is being evaluated","function::eval_dbl(vector,vector)");
<a name="__line1249"></a>	    return 0;
<a name="__line1250"></a>	}
<a name="__line1251"></a>	int dummy = 0;
<a name="__line1252"></a>	base_-&gt;eval_dbl(args,default_args_,pars,result_,&amp;dummy);
<a name="__line1253"></a>	return result_[0].dbl();
<a name="__line1254"></a>    }
<a name="__line1255"></a>
<a name="__line1256"></a>    double function::eval_dbl(const std::vector&lt;blop::var&gt; &amp;args) const
<a name="__line1257"></a>    {
<a name="__line1258"></a>	if(!base_)
<a name="__line1259"></a>	{
<a name="__line1260"></a>	    warning::print("Uninitialized function is being evaluated","function::eval_dbl(...)");
<a name="__line1261"></a>	    return 0;
<a name="__line1262"></a>	}
<a name="__line1263"></a>	int dummy = 0;
<a name="__line1264"></a>	base_-&gt;eval_dbl(args,default_args_,parameters_,result_,&amp;dummy);
<a name="__line1265"></a>	return result_[0].dbl();
<a name="__line1266"></a>    }
<a name="__line1267"></a>
<a name="__line1268"></a>    void function::meval(const std::vector&lt;blop::var&gt; &amp;args, std::vector&lt;blop::var&gt; &amp;result) const
<a name="__line1269"></a>    {
<a name="__line1270"></a>	if(!base_)
<a name="__line1271"></a>	{
<a name="__line1272"></a>	    result.resize(0);
<a name="__line1273"></a>	    warning::print("Uninitialized function is being evaluated","function::meval(...)");
<a name="__line1274"></a>	    return;
<a name="__line1275"></a>	}
<a name="__line1276"></a>	if(check_args_) make_arg_check_(args);
<a name="__line1277"></a>	result.resize(base_-&gt;n_out());
<a name="__line1278"></a>	int runind = 0;
<a name="__line1279"></a>	base_-&gt;eval(args, default_args_, parameters_, result, &amp;runind);
<a name="__line1280"></a>    }
<a name="__line1281"></a>
<a name="__line1282"></a>    void function::meval_dbl(const std::vector&lt;blop::var&gt; &amp;args, std::vector&lt;blop::var&gt; &amp;result) const
<a name="__line1283"></a>    {
<a name="__line1284"></a>	if(!base_)
<a name="__line1285"></a>	{
<a name="__line1286"></a>	    result.resize(0);
<a name="__line1287"></a>	    warning::print("Uninitialized function is being evaluated","function::meval_dbl(...)");
<a name="__line1288"></a>	    return;
<a name="__line1289"></a>	}
<a name="__line1290"></a>	result.resize(base_-&gt;n_out());
<a name="__line1291"></a>	int runind = 0;
<a name="__line1292"></a>	base_-&gt;eval_dbl(args, default_args_, parameters_, result, &amp;runind);
<a name="__line1293"></a>    }
<a name="__line1294"></a>
<a name="__line1295"></a>    void function::meval_dbl(const std::vector&lt;blop::var&gt; &amp;args,
<a name="__line1296"></a>			     const std::vector&lt;blop::var&gt; &amp;pars,
<a name="__line1297"></a>			     std::vector&lt;blop::var&gt; &amp;result) const
<a name="__line1298"></a>    {
<a name="__line1299"></a>	if(!base_)
<a name="__line1300"></a>	{
<a name="__line1301"></a>	    result.resize(0);
<a name="__line1302"></a>	    warning::print("Uninitialized function is being evaluated","function::meval_dbl(...)");
<a name="__line1303"></a>	    return;
<a name="__line1304"></a>	}
<a name="__line1305"></a>	result.resize(base_-&gt;n_out());
<a name="__line1306"></a>	int runind = 0;
<a name="__line1307"></a>	base_-&gt;eval_dbl(args, default_args_, pars, result, &amp;runind);
<a name="__line1308"></a>    }
<a name="__line1309"></a>
<a name="__line1310"></a>    var function::operator()() const
<a name="__line1311"></a>    {
<a name="__line1312"></a>	vector&lt;var&gt; a;
<a name="__line1313"></a>	return eval(a);
<a name="__line1314"></a>    }
<a name="__line1315"></a>    var function::operator()(const var &amp;x) const
<a name="__line1316"></a>    {
<a name="__line1317"></a>	vector&lt;var&gt; a;
<a name="__line1318"></a>	a.push_back(x);
<a name="__line1319"></a>	return eval(a);
<a name="__line1320"></a>    }
<a name="__line1321"></a>    var function::operator()(const var &amp;x,const var &amp;y) const
<a name="__line1322"></a>    {
<a name="__line1323"></a>	vector&lt;var&gt; a;
<a name="__line1324"></a>	a.push_back(x);
<a name="__line1325"></a>	a.push_back(y);
<a name="__line1326"></a>	return eval(a);
<a name="__line1327"></a>    }
<a name="__line1328"></a>    var function::operator()(const var &amp;x,const var &amp;y,const var &amp;z) const
<a name="__line1329"></a>    {
<a name="__line1330"></a>	vector&lt;var&gt; arg;
<a name="__line1331"></a>	arg.push_back(x);
<a name="__line1332"></a>	arg.push_back(y);
<a name="__line1333"></a>	arg.push_back(z);
<a name="__line1334"></a>	return eval(arg);
<a name="__line1335"></a>    }
<a name="__line1336"></a>    var function::operator()(const var &amp;x,const var &amp;y,const var &amp;z,const var &amp;w) const
<a name="__line1337"></a>    {
<a name="__line1338"></a>	vector&lt;var&gt; arg;
<a name="__line1339"></a>	arg.push_back(x);
<a name="__line1340"></a>	arg.push_back(y);
<a name="__line1341"></a>	arg.push_back(z);
<a name="__line1342"></a>	arg.push_back(w);
<a name="__line1343"></a>	return eval(arg);
<a name="__line1344"></a>    }
<a name="__line1345"></a>    var function::operator()(const var &amp;x,const var &amp;y,const var &amp;z,const var &amp;w,const var &amp;v) const
<a name="__line1346"></a>    {
<a name="__line1347"></a>	vector&lt;var&gt; arg;
<a name="__line1348"></a>	arg.push_back(x);
<a name="__line1349"></a>	arg.push_back(y);
<a name="__line1350"></a>	arg.push_back(z);
<a name="__line1351"></a>	arg.push_back(w);
<a name="__line1352"></a>	arg.push_back(v);
<a name="__line1353"></a>	return eval(arg);
<a name="__line1354"></a>    }
<a name="__line1355"></a>    var function::operator()(const var &amp;x,const var &amp;y,const var &amp;z,const var &amp;w,const var &amp;v,const var &amp;a) const
<a name="__line1356"></a>    {
<a name="__line1357"></a>	vector&lt;var&gt; arg;
<a name="__line1358"></a>	arg.push_back(x);
<a name="__line1359"></a>	arg.push_back(y);
<a name="__line1360"></a>	arg.push_back(z);
<a name="__line1361"></a>	arg.push_back(w);
<a name="__line1362"></a>	arg.push_back(v);
<a name="__line1363"></a>	arg.push_back(a);
<a name="__line1364"></a>	return eval(arg);
<a name="__line1365"></a>    }
<a name="__line1366"></a>
<a name="__line1367"></a>
<a name="__line1368"></a>    const function &amp;function::operator= (const function &amp;f)
<a name="__line1369"></a>    {
<a name="__line1370"></a>	delete base_;
<a name="__line1371"></a>	if(f.base_) base_ = f.base_-&gt;clone();
<a name="__line1372"></a>	else base_ = 0;
<a name="__line1373"></a>	parameters_ = f.parameters_;
<a name="__line1374"></a>	init_();
<a name="__line1375"></a>
<a name="__line1376"></a>	if(!f.derivatives_.empty())
<a name="__line1377"></a>	{
<a name="__line1378"></a>	    cerr&lt;&lt;"function::operator= does not yet copy derivatives, request it strongly at the author"&lt;&lt;endl;
<a name="__line1379"></a>	    exit(1);
<a name="__line1380"></a>	}
<a name="__line1381"></a>
<a name="__line1382"></a>	<span class=comment>//nargs(nargs_);</span>
<a name="__line1383"></a>	<span class=comment>//npars(npars_);</span>
<a name="__line1384"></a>
<a name="__line1385"></a>	default_args_ = f.default_args_;
<a name="__line1386"></a>	arg_min_ = f.arg_min_;
<a name="__line1387"></a>	arg_max_ = f.arg_max_;
<a name="__line1388"></a>
<a name="__line1389"></a>        return *this;
<a name="__line1390"></a>    }
<a name="__line1391"></a>
<a name="__line1392"></a>    const function &amp;function::operator= (const var &amp;v)
<a name="__line1393"></a>    {
<a name="__line1394"></a>	delete base_;
<a name="__line1395"></a>	base_ = new constant(v);
<a name="__line1396"></a>	parameters_.clear();
<a name="__line1397"></a>	init_();
<a name="__line1398"></a>
<a name="__line1399"></a>	for(deriv_map::iterator i1 = derivatives_.begin(); i1 != derivatives_.end(); ++i1)
<a name="__line1400"></a>	{
<a name="__line1401"></a>	    delete (*i1).second;
<a name="__line1402"></a>	}
<a name="__line1403"></a>
<a name="__line1404"></a>	<span class=comment>//nargs(nargs_);</span>
<a name="__line1405"></a>	<span class=comment>//npars(npars_);</span>
<a name="__line1406"></a>        return *this;
<a name="__line1407"></a>    }
<a name="__line1408"></a>    const function &amp;function::operator= (const string &amp;v)
<a name="__line1409"></a>    {
<a name="__line1410"></a>	operator=(var(v));
<a name="__line1411"></a>	<span class=comment>//nargs(nargs_);</span>
<a name="__line1412"></a>	<span class=comment>//npars(npars_);</span>
<a name="__line1413"></a>	return *this;
<a name="__line1414"></a>    }
<a name="__line1415"></a>    const function &amp;function::operator= (const char *v)
<a name="__line1416"></a>    {
<a name="__line1417"></a>	operator=(var(v));
<a name="__line1418"></a>	return *this;
<a name="__line1419"></a>    }
<a name="__line1420"></a>
<a name="__line1421"></a>    const function &amp;function::operator= (double v)
<a name="__line1422"></a>    {
<a name="__line1423"></a>	if(v == unset)
<a name="__line1424"></a>	{
<a name="__line1425"></a>	    delete base_;
<a name="__line1426"></a>	    base_ = 0;
<a name="__line1427"></a>	    parameters_.clear();
<a name="__line1428"></a>	}
<a name="__line1429"></a>	else operator=(var(v));
<a name="__line1430"></a>	return *this;
<a name="__line1431"></a>    }
<a name="__line1432"></a>
<a name="__line1433"></a>
<a name="__line1434"></a>    <span class=comment>// ---------- operators, functions  -----------------------------------------------</span>
<a name="__line1435"></a>
<a name="__line1436"></a>    template &lt;class T&gt;
<a name="__line1437"></a>    void function::init_binary_(const function &amp;left, const function &amp;right)
<a name="__line1438"></a>    {
<a name="__line1439"></a>	print_param_value_ = (left.print_param_value_ || right.print_param_value_);
<a name="__line1440"></a>	delete base_;
<a name="__line1441"></a>	if(left.components() != right.components()) warning::print("Component mismatch","function::init_binary");
<a name="__line1442"></a>
<a name="__line1443"></a>	base_ = new T(left.base_, right.base_);
<a name="__line1444"></a>	init_();
<a name="__line1445"></a>	parameters_.resize(::max(left.parameters_.size(), right.parameters_.size()));
<a name="__line1446"></a>	unsigned int i=0; 
<a name="__line1447"></a>	for(; i&lt;left .parameters_.size(); ++i) parameters_[i] = left.parameters_[i];
<a name="__line1448"></a>	for(; i&lt;right.parameters_.size(); ++i) parameters_[i] = right.parameters_[i];
<a name="__line1449"></a>    }
<a name="__line1450"></a>
<a name="__line1451"></a>    template &lt;class T&gt;
<a name="__line1452"></a>    void function::init_unary_(const function &amp;operand)
<a name="__line1453"></a>    {
<a name="__line1454"></a>	print_param_value_ = operand.print_param_value_;
<a name="__line1455"></a>	delete base_;
<a name="__line1456"></a>	base_ = new T(operand.base_);
<a name="__line1457"></a>	init_();
<a name="__line1458"></a>	parameters_ = operand.parameters_;
<a name="__line1459"></a>    }
<a name="__line1460"></a>
<a name="__line1461"></a>    function operator&amp; (const function &amp;left, const function &amp;right)
<a name="__line1462"></a>    {
<a name="__line1463"></a>	function result;
<a name="__line1464"></a>	result.init_binary_&lt;function_core::concatenator&gt;(left,right);
<a name="__line1465"></a>	return result;
<a name="__line1466"></a>    }
<a name="__line1467"></a>
<a name="__line1468"></a>    function operator&amp;&amp; (const function &amp;left, const function &amp;right)
<a name="__line1469"></a>    {
<a name="__line1470"></a>	function result;
<a name="__line1471"></a>	result.init_binary_&lt;function_core::logical_and&gt;(left,right);
<a name="__line1472"></a>	return result;
<a name="__line1473"></a>    }
<a name="__line1474"></a>
<a name="__line1475"></a>    function operator|| (const function &amp;left, const function &amp;right)
<a name="__line1476"></a>    {
<a name="__line1477"></a>	function result;
<a name="__line1478"></a>	result.init_binary_&lt;function_core::logical_or&gt;(left,right);
<a name="__line1479"></a>	return result;
<a name="__line1480"></a>    }
<a name="__line1481"></a>
<a name="__line1482"></a>    function sqrt(const function &amp;o)
<a name="__line1483"></a>    {
<a name="__line1484"></a>	function result;
<a name="__line1485"></a>	result.init_unary_&lt;function_core::Sqrt&gt;(o);
<a name="__line1486"></a>	<span class=comment>//result.nargs(o.nargs_);</span>
<a name="__line1487"></a>	<span class=comment>//result.npars(o.npars_);</span>
<a name="__line1488"></a>	return result;
<a name="__line1489"></a>    }
<a name="__line1490"></a>
<a name="__line1491"></a>    function format(const function &amp;func, const function &amp;form)
<a name="__line1492"></a>    {
<a name="__line1493"></a>        return new function_core::format(func.base_,form.base_);
<a name="__line1494"></a>    }
<a name="__line1495"></a>
<a name="__line1496"></a>    function format(const function &amp;func, const var &amp;form)
<a name="__line1497"></a>    {
<a name="__line1498"></a>        return blop::format(func, blop::function(form));
<a name="__line1499"></a>    }
<a name="__line1500"></a>
<a name="__line1501"></a>    function max(const function &amp;y, const function &amp;x)
<a name="__line1502"></a>    {
<a name="__line1503"></a>	function result;
<a name="__line1504"></a>	result.init_binary_&lt;function_core::Max&gt;(y,x);
<a name="__line1505"></a>	return result;
<a name="__line1506"></a>    }
<a name="__line1507"></a>    function max(const function &amp;y, double x)
<a name="__line1508"></a>    {
<a name="__line1509"></a>	return max(y,function(x));
<a name="__line1510"></a>    }
<a name="__line1511"></a>    function max(double y, const function &amp;x)
<a name="__line1512"></a>    {
<a name="__line1513"></a>	return max(function(y),x);
<a name="__line1514"></a>    }
<a name="__line1515"></a>
<a name="__line1516"></a>    function min(const function &amp;y, const function &amp;x)
<a name="__line1517"></a>    {
<a name="__line1518"></a>	function result;
<a name="__line1519"></a>	result.init_binary_&lt;function_core::Min&gt;(y,x);
<a name="__line1520"></a>	return result;
<a name="__line1521"></a>    }
<a name="__line1522"></a>    function min(const function &amp;y, double x)
<a name="__line1523"></a>    {
<a name="__line1524"></a>	return min(y,function(x));
<a name="__line1525"></a>    }
<a name="__line1526"></a>    function min(double y, const function &amp;x)
<a name="__line1527"></a>    {
<a name="__line1528"></a>	return min(function(y),x);
<a name="__line1529"></a>    }
<a name="__line1530"></a>
<a name="__line1531"></a>    function maximum(const function &amp;func,
<a name="__line1532"></a>		     const function &amp;from,
<a name="__line1533"></a>		     const function &amp;to,
<a name="__line1534"></a>		     const function &amp;step)
<a name="__line1535"></a>    {
<a name="__line1536"></a>	if(func.is_constant())
<a name="__line1537"></a>	{
<a name="__line1538"></a>	    vector&lt;var&gt; args, result;
<a name="__line1539"></a>	    func.meval(args,result);
<a name="__line1540"></a>	    return result;
<a name="__line1541"></a>	}
<a name="__line1542"></a>	return new function_core::max_in_interval(func.base_,
<a name="__line1543"></a>						  from.base_,
<a name="__line1544"></a>						  to.base_,
<a name="__line1545"></a>						  step.base_);
<a name="__line1546"></a>    }
<a name="__line1547"></a>    function minimum(const function &amp;func,
<a name="__line1548"></a>		     const function &amp;from,
<a name="__line1549"></a>		     const function &amp;to,
<a name="__line1550"></a>		     const function &amp;step)
<a name="__line1551"></a>    {
<a name="__line1552"></a>	if(func.is_constant())
<a name="__line1553"></a>	{
<a name="__line1554"></a>	    vector&lt;var&gt; args, result;
<a name="__line1555"></a>	    func.meval(args,result);
<a name="__line1556"></a>	    return result;
<a name="__line1557"></a>	}
<a name="__line1558"></a>	return new function_core::min_in_interval(func.base_,
<a name="__line1559"></a>						  from.base_,
<a name="__line1560"></a>						  to.base_,
<a name="__line1561"></a>						  step.base_);
<a name="__line1562"></a>    }
<a name="__line1563"></a>    function integral(const function &amp;func,
<a name="__line1564"></a>		       const function &amp;from,
<a name="__line1565"></a>		       const function &amp;to,
<a name="__line1566"></a>		       const function &amp;step)
<a name="__line1567"></a>    {
<a name="__line1568"></a>	return new function_core::integral(func.base_,
<a name="__line1569"></a>					   from.base_,
<a name="__line1570"></a>					   to.base_,
<a name="__line1571"></a>					   step.base_);
<a name="__line1572"></a>    }
<a name="__line1573"></a>
<a name="__line1574"></a>    double integral(const function &amp;func, double from, double to, double step)
<a name="__line1575"></a>    {
<a name="__line1576"></a>        if(func.nargs()&gt;1)
<a name="__line1577"></a>            warning::print("The function to be integrated has more than 1 arguments!","integral(const function &amp;func, double from, double to, double step)");
<a name="__line1578"></a>        if(to&lt;=from)
<a name="__line1579"></a>        {
<a name="__line1580"></a>            warning::print("Upper integration limit is less than lower limit","integral(const function &amp;func, double from, double to, double step)");
<a name="__line1581"></a>            return 0;
<a name="__line1582"></a>        }
<a name="__line1583"></a>        if(step&lt;=0.0) step = (to-from)/100.0;
<a name="__line1584"></a>        double result = 0;
<a name="__line1585"></a>        for(double x=from; x&lt;to+0.1*step; x+=step)
<a name="__line1586"></a>        {
<a name="__line1587"></a>            result += func(x).dbl();
<a name="__line1588"></a>        }
<a name="__line1589"></a>        return result*step;
<a name="__line1590"></a>    }
<a name="__line1591"></a>
<a name="__line1592"></a>    function operator==(const function &amp;left, const function &amp;right)
<a name="__line1593"></a>    {
<a name="__line1594"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1595"></a>	{
<a name="__line1596"></a>	    if(left.components() != right.components()) return false;
<a name="__line1597"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1598"></a>	    left.meval(args,leftresult);
<a name="__line1599"></a>	    right.meval(args,rightresult);
<a name="__line1600"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) if(leftresult[i].dbl() != rightresult[i].dbl()) return false;
<a name="__line1601"></a>	    return true;
<a name="__line1602"></a>	}
<a name="__line1603"></a>	function result;
<a name="__line1604"></a>	result.init_binary_&lt;function_core::EqualDbl&gt;(left, right);
<a name="__line1605"></a>	return result;
<a name="__line1606"></a>    }
<a name="__line1607"></a>
<a name="__line1608"></a>    function operator==(const function  &amp;left, const var &amp;right)
<a name="__line1609"></a>    {
<a name="__line1610"></a>	return operator==(left,function(right));
<a name="__line1611"></a>    }
<a name="__line1612"></a>    function operator==(const var  &amp;left, const function &amp;right)
<a name="__line1613"></a>    {
<a name="__line1614"></a>	return operator==(function(left),right);
<a name="__line1615"></a>    }
<a name="__line1616"></a>    function operator==(const function  &amp;left, double right)
<a name="__line1617"></a>    {
<a name="__line1618"></a>	return operator==(left,function(right));
<a name="__line1619"></a>    }
<a name="__line1620"></a>    function operator==(double left, const function &amp;right)
<a name="__line1621"></a>    {
<a name="__line1622"></a>	return operator==(function(left),right);
<a name="__line1623"></a>    }
<a name="__line1624"></a>    function operator==(const function  &amp;left, int right)
<a name="__line1625"></a>    {
<a name="__line1626"></a>	return operator==(left,function(right));
<a name="__line1627"></a>    }
<a name="__line1628"></a>    function operator==(int left, const function &amp;right)
<a name="__line1629"></a>    {
<a name="__line1630"></a>	return operator==(function(left),right);
<a name="__line1631"></a>    }
<a name="__line1632"></a>
<a name="__line1633"></a>    function operator==(const function &amp;left, const std::string &amp;right)
<a name="__line1634"></a>    {
<a name="__line1635"></a>	function c = right;
<a name="__line1636"></a>	function result;
<a name="__line1637"></a>	result.init_binary_&lt;function_core::EqualStr&gt;(left,c);
<a name="__line1638"></a>	return result;
<a name="__line1639"></a>    }
<a name="__line1640"></a>    function operator==(const std::string &amp;left, const function &amp;right)
<a name="__line1641"></a>    {
<a name="__line1642"></a>	function c = left;
<a name="__line1643"></a>	function result;
<a name="__line1644"></a>	result.init_binary_&lt;function_core::EqualStr&gt;(c,right);
<a name="__line1645"></a>	return result;
<a name="__line1646"></a>    }
<a name="__line1647"></a>    function operator==(const function &amp;left, const char *right)
<a name="__line1648"></a>    {
<a name="__line1649"></a>	function c = right;
<a name="__line1650"></a>	function result;
<a name="__line1651"></a>	result.init_binary_&lt;function_core::EqualStr&gt;(left,c);
<a name="__line1652"></a>	return result;
<a name="__line1653"></a>    }
<a name="__line1654"></a>    function operator==(const char *left, const function &amp;right)
<a name="__line1655"></a>    {
<a name="__line1656"></a>	function c = left;
<a name="__line1657"></a>	function result;
<a name="__line1658"></a>	result.init_binary_&lt;function_core::EqualStr&gt;(c,right);
<a name="__line1659"></a>	return result;
<a name="__line1660"></a>    }
<a name="__line1661"></a>
<a name="__line1662"></a>    function operator!=(const function &amp;left, const function &amp;right)
<a name="__line1663"></a>    {
<a name="__line1664"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1665"></a>	{
<a name="__line1666"></a>	    if(left.components() != right.components()) return false;
<a name="__line1667"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1668"></a>	    left.meval(args,leftresult);
<a name="__line1669"></a>	    right.meval(args,rightresult);
<a name="__line1670"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) if(leftresult[i].dbl() == rightresult[i].dbl()) return false;
<a name="__line1671"></a>	    return true;
<a name="__line1672"></a>	}
<a name="__line1673"></a>	function result;
<a name="__line1674"></a>	result.init_binary_&lt;function_core::NotEqualDbl&gt;(left,right);
<a name="__line1675"></a>	return result;
<a name="__line1676"></a>    }
<a name="__line1677"></a>    function operator!=(const function &amp;left, double right)
<a name="__line1678"></a>    {
<a name="__line1679"></a>	return operator!=(left,function(right));
<a name="__line1680"></a>    }
<a name="__line1681"></a>    function operator!=(double left, const function &amp;right)
<a name="__line1682"></a>    {
<a name="__line1683"></a>	return operator!=(function(left),right);
<a name="__line1684"></a>    }
<a name="__line1685"></a>
<a name="__line1686"></a>    function operator&lt; (const function &amp;left, const function &amp;right)
<a name="__line1687"></a>    {
<a name="__line1688"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1689"></a>	{
<a name="__line1690"></a>	    if(left.components() != right.components()) return false;
<a name="__line1691"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1692"></a>	    left.meval(args,leftresult);
<a name="__line1693"></a>	    right.meval(args,rightresult);
<a name="__line1694"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) if(leftresult[i].dbl() &gt;= rightresult[i].dbl()) return false;
<a name="__line1695"></a>	    return true;
<a name="__line1696"></a>	}
<a name="__line1697"></a>	function result;
<a name="__line1698"></a>	result.init_binary_&lt;function_core::LessThan&gt;(left,right);
<a name="__line1699"></a>	return result;
<a name="__line1700"></a>    }
<a name="__line1701"></a>    function operator&lt; (const function &amp;left, double right)
<a name="__line1702"></a>    {
<a name="__line1703"></a>	return operator&lt;(left,function(right));
<a name="__line1704"></a>    }
<a name="__line1705"></a>    function operator&lt; (double left, const function &amp;right)
<a name="__line1706"></a>    {
<a name="__line1707"></a>	return operator&lt;(function(left),right);
<a name="__line1708"></a>    }
<a name="__line1709"></a>
<a name="__line1710"></a>    function operator&lt;= (const function &amp;left, const function &amp;right)
<a name="__line1711"></a>    {
<a name="__line1712"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1713"></a>	{
<a name="__line1714"></a>	    if(left.components() != right.components()) return false;
<a name="__line1715"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1716"></a>	    left.meval(args,leftresult);
<a name="__line1717"></a>	    right.meval(args,rightresult);
<a name="__line1718"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) if(leftresult[i].dbl() &gt; rightresult[i].dbl()) return false;
<a name="__line1719"></a>	    return true;
<a name="__line1720"></a>	}
<a name="__line1721"></a>	function result;
<a name="__line1722"></a>	result.init_binary_&lt;function_core::LessEqual&gt;(left,right);
<a name="__line1723"></a>	return result;
<a name="__line1724"></a>    }
<a name="__line1725"></a>    function operator&lt;= (const function &amp;left, double right)
<a name="__line1726"></a>    {
<a name="__line1727"></a>	return operator&lt;=(left,function(right));
<a name="__line1728"></a>    }
<a name="__line1729"></a>    function operator&lt;= (double left, const function &amp;right)
<a name="__line1730"></a>    {
<a name="__line1731"></a>	return operator&lt;=(function(left),right);
<a name="__line1732"></a>    }
<a name="__line1733"></a>
<a name="__line1734"></a>    function operator&gt; (const function &amp;left, const function &amp;right)
<a name="__line1735"></a>    {
<a name="__line1736"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1737"></a>	{
<a name="__line1738"></a>	    if(left.components() != right.components()) return false;
<a name="__line1739"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1740"></a>	    left.meval(args,leftresult);
<a name="__line1741"></a>	    right.meval(args,rightresult);
<a name="__line1742"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) if(leftresult[i].dbl() &lt;= rightresult[i].dbl()) return false;
<a name="__line1743"></a>	    return true;
<a name="__line1744"></a>	}
<a name="__line1745"></a>	function result;
<a name="__line1746"></a>	result.init_binary_&lt;function_core::GreaterThan&gt;(left,right);
<a name="__line1747"></a>	return result;
<a name="__line1748"></a>    }
<a name="__line1749"></a>    function operator&gt; (const function &amp;left, double right)
<a name="__line1750"></a>    {
<a name="__line1751"></a>	return operator&gt;(left,function(right));
<a name="__line1752"></a>    }
<a name="__line1753"></a>    function operator&gt; (double left, const function &amp;right)
<a name="__line1754"></a>    {
<a name="__line1755"></a>	return operator&gt;(function(left),right);
<a name="__line1756"></a>    }
<a name="__line1757"></a>
<a name="__line1758"></a>    function operator&gt;= (const function &amp;left, const function &amp;right)
<a name="__line1759"></a>    {
<a name="__line1760"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1761"></a>	{
<a name="__line1762"></a>	    if(left.components() != right.components()) return false;
<a name="__line1763"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1764"></a>	    left.meval(args,leftresult);
<a name="__line1765"></a>	    right.meval(args,rightresult);
<a name="__line1766"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) if(leftresult[i].dbl() &lt; rightresult[i].dbl()) return false;
<a name="__line1767"></a>	    return true;
<a name="__line1768"></a>	}
<a name="__line1769"></a>	function result;
<a name="__line1770"></a>	result.init_binary_&lt;function_core::GreaterEqual&gt;(left,right);
<a name="__line1771"></a>	return result;
<a name="__line1772"></a>    }
<a name="__line1773"></a>    function operator&gt;= (const function &amp;left, double right)
<a name="__line1774"></a>    {
<a name="__line1775"></a>	return operator&gt;=(left,function(right));
<a name="__line1776"></a>    }
<a name="__line1777"></a>    function operator&gt;= (double left, const function &amp;right)
<a name="__line1778"></a>    {
<a name="__line1779"></a>	return operator&gt;=(function(left),right);
<a name="__line1780"></a>    }
<a name="__line1781"></a>
<a name="__line1782"></a>    function operator+ (const function &amp;left, const function &amp;right)
<a name="__line1783"></a>    {
<a name="__line1784"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1785"></a>	{
<a name="__line1786"></a>	    warning::print("Uninitialized function in operator+");
<a name="__line1787"></a>	    return 0.0;
<a name="__line1788"></a>	}
<a name="__line1789"></a>	if(left.components() != right.components()) warning::print("Number of components of the two functions is not equal");
<a name="__line1790"></a>
<a name="__line1791"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1792"></a>	{
<a name="__line1793"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1794"></a>	    left.meval(args,leftresult);
<a name="__line1795"></a>	    right.meval(args,rightresult);
<a name="__line1796"></a>	    if(leftresult.size()&lt;rightresult.size()) leftresult.resize(rightresult.size());
<a name="__line1797"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) leftresult[i] = leftresult[i].dbl() + (i&lt;rightresult.size()?rightresult[i].dbl():0);
<a name="__line1798"></a>	    return leftresult;
<a name="__line1799"></a>	}
<a name="__line1800"></a>	
<a name="__line1801"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(left.base_);
<a name="__line1802"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(right.base_);
<a name="__line1803"></a>	if(c1 &amp;&amp; c2) return c1-&gt;value_.dbl() + c2-&gt;value_.dbl();
<a name="__line1804"></a>	if(c1 &amp;&amp; c1-&gt;value_.dbl() == 0.0) return right;
<a name="__line1805"></a>	if(c2 &amp;&amp; c2-&gt;value_.dbl() == 0.0) return left;
<a name="__line1806"></a>	function result;
<a name="__line1807"></a>	result.init_binary_&lt;function_core::Add&gt;(left,right);
<a name="__line1808"></a>	return result;
<a name="__line1809"></a>    }
<a name="__line1810"></a>    function operator+ (const function  &amp;left, double right)
<a name="__line1811"></a>    {
<a name="__line1812"></a>	return operator+(left,function(right));
<a name="__line1813"></a>    }
<a name="__line1814"></a>    function operator+ (double left, const function &amp;right)
<a name="__line1815"></a>    {
<a name="__line1816"></a>	return operator+(function(left),right);
<a name="__line1817"></a>    }
<a name="__line1818"></a>    function operator+ (const function  &amp;left, int right)
<a name="__line1819"></a>    {
<a name="__line1820"></a>	return operator+(left,function(right));
<a name="__line1821"></a>    }
<a name="__line1822"></a>    function operator+ (int left, const function &amp;right)
<a name="__line1823"></a>    {
<a name="__line1824"></a>	return operator+(function(left),right);
<a name="__line1825"></a>    }
<a name="__line1826"></a>    function operator+ (const function  &amp;left, const var &amp;right)
<a name="__line1827"></a>    {
<a name="__line1828"></a>	return operator+(left,function(right));
<a name="__line1829"></a>    }
<a name="__line1830"></a>    function operator+ (const var &amp;left, const function &amp;right)
<a name="__line1831"></a>    {
<a name="__line1832"></a>	return operator+(function(left),right);
<a name="__line1833"></a>    }
<a name="__line1834"></a>
<a name="__line1835"></a>    function operator- (const function &amp;left, const function &amp;right)
<a name="__line1836"></a>    {
<a name="__line1837"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1838"></a>	{
<a name="__line1839"></a>	    warning::print("Uninitialized function in operator+");
<a name="__line1840"></a>	    return 0.0;
<a name="__line1841"></a>	}
<a name="__line1842"></a>	if(left.components() != right.components()) warning::print("Number of components of the two functions is not equal");
<a name="__line1843"></a>
<a name="__line1844"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1845"></a>	{
<a name="__line1846"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1847"></a>	    left.meval(args,leftresult);
<a name="__line1848"></a>	    right.meval(args,rightresult);
<a name="__line1849"></a>	    if(leftresult.size()&lt;rightresult.size()) leftresult.resize(rightresult.size());
<a name="__line1850"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) leftresult[i] = leftresult[i].dbl() - (i&lt;rightresult.size()?rightresult[i].dbl():0);
<a name="__line1851"></a>	    return leftresult;
<a name="__line1852"></a>	}
<a name="__line1853"></a>	
<a name="__line1854"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(left.base_);
<a name="__line1855"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(right.base_);
<a name="__line1856"></a>	if(c1 &amp;&amp; c2) return c1-&gt;value_.dbl() - c2-&gt;value_.dbl();
<a name="__line1857"></a>	if(c2 &amp;&amp; c2-&gt;value_.dbl() == 0.0) return left;
<a name="__line1858"></a>	if(c1 &amp;&amp; c1-&gt;value_.dbl() == 0.0)
<a name="__line1859"></a>	{
<a name="__line1860"></a>	    function result;
<a name="__line1861"></a>	    result.init_unary_&lt;function_core::Neg&gt;(right);
<a name="__line1862"></a>	    return result;
<a name="__line1863"></a>	}
<a name="__line1864"></a>	function result;
<a name="__line1865"></a>	result.init_binary_&lt;function_core::Sub&gt;(left,right);
<a name="__line1866"></a>	return result;
<a name="__line1867"></a>    }
<a name="__line1868"></a>    function operator- (const function &amp;left, double right)
<a name="__line1869"></a>    {
<a name="__line1870"></a>	return operator-(left,function(right));
<a name="__line1871"></a>    }
<a name="__line1872"></a>    function operator- (double left, const function &amp;right)
<a name="__line1873"></a>    {
<a name="__line1874"></a>	return operator-(function(left), right);
<a name="__line1875"></a>    }
<a name="__line1876"></a>    function operator- (const function &amp;left, int right)
<a name="__line1877"></a>    {
<a name="__line1878"></a>	return operator-(left,function(right));
<a name="__line1879"></a>    }
<a name="__line1880"></a>    function operator- (int left, const function &amp;right)
<a name="__line1881"></a>    {
<a name="__line1882"></a>	return operator-(function(left), right);
<a name="__line1883"></a>    }
<a name="__line1884"></a>    function operator- (const function &amp;left, const var &amp;right)
<a name="__line1885"></a>    {
<a name="__line1886"></a>	return operator-(left,function(right));
<a name="__line1887"></a>    }
<a name="__line1888"></a>    function operator- (const var &amp;left, const function &amp;right)
<a name="__line1889"></a>    {
<a name="__line1890"></a>	return operator-(function(left), right);
<a name="__line1891"></a>    }
<a name="__line1892"></a>
<a name="__line1893"></a>    function operator% (const function &amp;left, const function &amp;right)
<a name="__line1894"></a>    {
<a name="__line1895"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1896"></a>	{
<a name="__line1897"></a>	    warning::print("Uninitialized function in operator+");
<a name="__line1898"></a>	    return 0.0;
<a name="__line1899"></a>	}
<a name="__line1900"></a>	if(left.components() != right.components()) warning::print("Number of components of the two functions is not equal");
<a name="__line1901"></a>
<a name="__line1902"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1903"></a>	{
<a name="__line1904"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1905"></a>	    left.meval(args,leftresult);
<a name="__line1906"></a>	    right.meval(args,rightresult);
<a name="__line1907"></a>	    if(leftresult.size()&lt;rightresult.size()) leftresult.resize(rightresult.size());
<a name="__line1908"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) leftresult[i] = leftresult[i].integer() % (i&lt;rightresult.size()?rightresult[i].integer():1);
<a name="__line1909"></a>	    return leftresult;
<a name="__line1910"></a>	}
<a name="__line1911"></a>
<a name="__line1912"></a>	function result;
<a name="__line1913"></a>	result.init_binary_&lt;function_core::Mod&gt;(left,right);
<a name="__line1914"></a>	return result;
<a name="__line1915"></a>    }
<a name="__line1916"></a>
<a name="__line1917"></a>    function cmp_mul(const function &amp;left, const function &amp;right)
<a name="__line1918"></a>    {
<a name="__line1919"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1920"></a>	{
<a name="__line1921"></a>	    warning::print("Uninitialized function in cmp_mul");
<a name="__line1922"></a>	    return 0.0;
<a name="__line1923"></a>	}
<a name="__line1924"></a>        function result;
<a name="__line1925"></a>        result.init_binary_&lt;function_core::cmp_mul&gt;(left,right);
<a name="__line1926"></a>        return result;
<a name="__line1927"></a>    }
<a name="__line1928"></a>    function cmp_div(const function &amp;left, const function &amp;right)
<a name="__line1929"></a>    {
<a name="__line1930"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1931"></a>	{
<a name="__line1932"></a>	    warning::print("Uninitialized function in cmp_mul");
<a name="__line1933"></a>	    return 0.0;
<a name="__line1934"></a>	}
<a name="__line1935"></a>        function result;
<a name="__line1936"></a>        result.init_binary_&lt;function_core::cmp_div&gt;(left,right);
<a name="__line1937"></a>        return result;
<a name="__line1938"></a>    }
<a name="__line1939"></a>
<a name="__line1940"></a>    function operator* (const function &amp;left, const function &amp;right)
<a name="__line1941"></a>    {
<a name="__line1942"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1943"></a>	{
<a name="__line1944"></a>	    warning::print("Uninitialized function in operator+");
<a name="__line1945"></a>	    return 0.0;
<a name="__line1946"></a>	}
<a name="__line1947"></a>	<span class=comment>//if(left.components() != right.components()) warning::print("Number of components of the two functions is not equal");</span>
<a name="__line1948"></a>
<a name="__line1949"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line1950"></a>	{
<a name="__line1951"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line1952"></a>	    left.meval(args,leftresult);
<a name="__line1953"></a>	    right.meval(args,rightresult);
<a name="__line1954"></a>	    if(leftresult.size()&lt;rightresult.size()) leftresult.resize(rightresult.size());
<a name="__line1955"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) leftresult[i] = leftresult[i].dbl() * (i&lt;rightresult.size()?rightresult[i].dbl():0);
<a name="__line1956"></a>	    return leftresult;
<a name="__line1957"></a>	}
<a name="__line1958"></a>	
<a name="__line1959"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(left.base_);
<a name="__line1960"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(right.base_);
<a name="__line1961"></a>	if( (c1 &amp;&amp; c1-&gt;value_.dbl() == 0.0) || (c2 &amp;&amp; c2-&gt;value_.dbl() == 0.0)) return 0.0;
<a name="__line1962"></a>	if(c1 &amp;&amp; c2) return c1-&gt;value_.dbl()*c2-&gt;value_.dbl();
<a name="__line1963"></a>	if(c1 &amp;&amp; c1-&gt;value_.dbl() == 1.0) return right;
<a name="__line1964"></a>	if(c2 &amp;&amp; c2-&gt;value_.dbl() == 1.0) return left;
<a name="__line1965"></a>	function result;
<a name="__line1966"></a>	result.init_binary_&lt;function_core::Mul&gt;(left,right);
<a name="__line1967"></a>	return result;
<a name="__line1968"></a>    }
<a name="__line1969"></a>    function operator* (const function &amp;left, double right)
<a name="__line1970"></a>    {
<a name="__line1971"></a>	return operator*(left, function(right));
<a name="__line1972"></a>    }
<a name="__line1973"></a>    function operator* (double left, const function &amp;right)
<a name="__line1974"></a>    {
<a name="__line1975"></a>	return operator*(function(left),right);
<a name="__line1976"></a>    }
<a name="__line1977"></a>    function operator* (const function &amp;left, int right)
<a name="__line1978"></a>    {
<a name="__line1979"></a>	return operator*(left, function(right));
<a name="__line1980"></a>    }
<a name="__line1981"></a>    function operator* (int left, const function &amp;right)
<a name="__line1982"></a>    {
<a name="__line1983"></a>	return operator*(function(left),right);
<a name="__line1984"></a>    }
<a name="__line1985"></a>    function operator* (const function &amp;left, const var &amp;right)
<a name="__line1986"></a>    {
<a name="__line1987"></a>	return operator*(left, function(right));
<a name="__line1988"></a>    }
<a name="__line1989"></a>    function operator* (const var &amp;left, const function &amp;right)
<a name="__line1990"></a>    {
<a name="__line1991"></a>	return operator*(function(left),right);
<a name="__line1992"></a>    }
<a name="__line1993"></a>
<a name="__line1994"></a>    function operator/ (const function &amp;left, const function &amp;right)
<a name="__line1995"></a>    {
<a name="__line1996"></a>	if(!left.initialized() || !right.initialized())
<a name="__line1997"></a>	{
<a name="__line1998"></a>	    warning::print("Uninitialized function in operator+");
<a name="__line1999"></a>	    return 0.0;
<a name="__line2000"></a>	}
<a name="__line2001"></a>	if(left.components() != right.components()) warning::print("Number of components of the two functions is not equal");
<a name="__line2002"></a>
<a name="__line2003"></a>	if(left.is_constant() &amp;&amp; right.is_constant())
<a name="__line2004"></a>	{
<a name="__line2005"></a>	    vector&lt;var&gt; args, leftresult, rightresult;
<a name="__line2006"></a>	    left.meval(args,leftresult);
<a name="__line2007"></a>	    right.meval(args,rightresult);
<a name="__line2008"></a>	    if(leftresult.size()&lt;rightresult.size()) leftresult.resize(rightresult.size());
<a name="__line2009"></a>	    for(unsigned int i=0; i&lt;leftresult.size(); ++i) leftresult[i] = leftresult[i].dbl() / (i&lt;rightresult.size()?rightresult[i].dbl():0);
<a name="__line2010"></a>	    return leftresult;
<a name="__line2011"></a>	}
<a name="__line2012"></a>	
<a name="__line2013"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(left.base_);
<a name="__line2014"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(right.base_);
<a name="__line2015"></a>	if(c1 &amp;&amp; c2) return c1-&gt;value_.dbl()/c2-&gt;value_.dbl();
<a name="__line2016"></a>	if(c1 &amp;&amp; c1-&gt;value_.dbl()==0.0) return 0.0;
<a name="__line2017"></a>	if(c2 &amp;&amp; c2-&gt;value_.dbl()==1.0) return left;
<a name="__line2018"></a>	function result;
<a name="__line2019"></a>	result.init_binary_&lt;function_core::Div&gt;(left,right);
<a name="__line2020"></a>	return result;
<a name="__line2021"></a>    }
<a name="__line2022"></a>    function operator/ (const function &amp;left, double right)
<a name="__line2023"></a>    {
<a name="__line2024"></a>	return operator/(left,function(right));
<a name="__line2025"></a>    }
<a name="__line2026"></a>    function operator/ (double left, const function &amp;right)
<a name="__line2027"></a>    {
<a name="__line2028"></a>	return operator/(function(left),right);
<a name="__line2029"></a>    }
<a name="__line2030"></a>    function operator/ (const function &amp;left, int right)
<a name="__line2031"></a>    {
<a name="__line2032"></a>	return operator/(left,function(right));
<a name="__line2033"></a>    }
<a name="__line2034"></a>    function operator/ (int left, const function &amp;right)
<a name="__line2035"></a>    {
<a name="__line2036"></a>	return operator/(function(left),right);
<a name="__line2037"></a>    }
<a name="__line2038"></a>    function operator/ (const function &amp;left, const var &amp;right)
<a name="__line2039"></a>    {
<a name="__line2040"></a>	return operator/(left,function(right));
<a name="__line2041"></a>    }
<a name="__line2042"></a>    function operator/ (const var &amp;left, const function &amp;right)
<a name="__line2043"></a>    {
<a name="__line2044"></a>	return operator/(function(left),right);
<a name="__line2045"></a>    }
<a name="__line2046"></a>
<a name="__line2047"></a>    function operator- (const function &amp;o)
<a name="__line2048"></a>    {
<a name="__line2049"></a>	if(o.is_constant())
<a name="__line2050"></a>	{
<a name="__line2051"></a>	    vector&lt;var&gt; args, result;
<a name="__line2052"></a>	    o.meval(args,result);
<a name="__line2053"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = -result[i].dbl();
<a name="__line2054"></a>	    return result;
<a name="__line2055"></a>	}
<a name="__line2056"></a>	
<a name="__line2057"></a>	function result;
<a name="__line2058"></a>	result.init_unary_&lt;function_core::Neg&gt;(o);
<a name="__line2059"></a>	return result;
<a name="__line2060"></a>    }
<a name="__line2061"></a>
<a name="__line2062"></a>
<a name="__line2063"></a>    function atan2(const function &amp;y, const function &amp;x)
<a name="__line2064"></a>    {
<a name="__line2065"></a>	if(y.components() != x.components()) warning::print("Number of function components is not equal","atan2(function,function)");
<a name="__line2066"></a>	if(y.is_constant() &amp;&amp; x.is_constant())
<a name="__line2067"></a>	{
<a name="__line2068"></a>	    vector&lt;var&gt; args, yresult,xresult;
<a name="__line2069"></a>	    y.meval(args,yresult);
<a name="__line2070"></a>	    x.meval(args,xresult);
<a name="__line2071"></a>	    if(xresult.size()&gt;yresult.size()) yresult.resize(xresult.size());
<a name="__line2072"></a>	    for(unsigned int i=0; i&lt;yresult.size(); ++i) yresult[i] = ::atan2(yresult[i].dbl(),(i&lt;xresult.size()?xresult[i].dbl():0.0));
<a name="__line2073"></a>	    return yresult;
<a name="__line2074"></a>	}
<a name="__line2075"></a>	function_core::constant *yc = dynamic_cast&lt;constant *&gt;(y.base_);
<a name="__line2076"></a>	function_core::constant *xc = dynamic_cast&lt;constant *&gt;(x.base_);
<a name="__line2077"></a>	if(yc &amp;&amp; xc) return ::atan2(yc-&gt;value_.dbl(),xc-&gt;value_.dbl());
<a name="__line2078"></a>	function result;
<a name="__line2079"></a>	result.init_binary_&lt;function_core::Atan2&gt;(y,x);
<a name="__line2080"></a>	return result;
<a name="__line2081"></a>    }
<a name="__line2082"></a>    function atan2(double y, const function &amp;x)
<a name="__line2083"></a>    {
<a name="__line2084"></a>	return atan2(function(y),x);
<a name="__line2085"></a>    }
<a name="__line2086"></a>    function atan2(const function &amp;y, double x)
<a name="__line2087"></a>    {
<a name="__line2088"></a>	return atan2(y,function(x));
<a name="__line2089"></a>    }
<a name="__line2090"></a>
<a name="__line2091"></a>    function pow(const function &amp;a,const function &amp;exponent)
<a name="__line2092"></a>    {
<a name="__line2093"></a>	if(a.components() != exponent.components()) warning::print("Number of function components is not equal","pow(function,function)");
<a name="__line2094"></a>	if(a.is_constant() &amp;&amp; exponent.is_constant())
<a name="__line2095"></a>	{
<a name="__line2096"></a>	    vector&lt;var&gt; args, aresult,eresult;
<a name="__line2097"></a>	    a.meval(args,aresult);
<a name="__line2098"></a>	    exponent.meval(args,eresult);
<a name="__line2099"></a>	    if(eresult.size()&gt;aresult.size()) aresult.resize(eresult.size());
<a name="__line2100"></a>	    for(unsigned int i=0; i&lt;aresult.size(); ++i) aresult[i] = ::pow(aresult[i].dbl(),(i&lt;eresult.size()?eresult[i].dbl():0.0));
<a name="__line2101"></a>	    return aresult;
<a name="__line2102"></a>	}
<a name="__line2103"></a>	function_core::constant *ac = dynamic_cast&lt;constant *&gt;(a.base_);
<a name="__line2104"></a>	function_core::constant *ec = dynamic_cast&lt;constant *&gt;(exponent.base_);
<a name="__line2105"></a>	if(ac &amp;&amp; ec)
<a name="__line2106"></a>        {
<a name="__line2107"></a>            return ::pow(ac-&gt;value_.dbl(), ec-&gt;value_.dbl());
<a name="__line2108"></a>        }
<a name="__line2109"></a>	if(ec)
<a name="__line2110"></a>	{
<a name="__line2111"></a>	    if(ec-&gt;value_.dbl() == 0.0) return 1.0;
<a name="__line2112"></a>	    if(ec-&gt;value_.dbl() == 1.0) return a;
<a name="__line2113"></a>	}
<a name="__line2114"></a>	function result;
<a name="__line2115"></a>	result.init_binary_&lt;function_core::Pow&gt;(a,exponent);
<a name="__line2116"></a>	return result;
<a name="__line2117"></a>    }
<a name="__line2118"></a>    function pow(double a, const function  &amp;exponent)
<a name="__line2119"></a>    {
<a name="__line2120"></a>	return pow(function(a),exponent);
<a name="__line2121"></a>    }
<a name="__line2122"></a>    function pow(const function &amp;a,double exponent)
<a name="__line2123"></a>    {
<a name="__line2124"></a>	return pow(a,function(exponent));
<a name="__line2125"></a>    }
<a name="__line2126"></a>    function pow(const function &amp;a,int exponent)
<a name="__line2127"></a>    {
<a name="__line2128"></a>	function_core::constant *ac = dynamic_cast&lt;constant *&gt;(a.base_);
<a name="__line2129"></a>	if(ac) return ::pow(ac-&gt;value_.dbl(), exponent);
<a name="__line2130"></a>
<a name="__line2131"></a>	<span class=comment>// this function should be very similar to function::init_unary_</span>
<a name="__line2132"></a>	function result(new Ipow(a.base_,exponent));
<a name="__line2133"></a>	result.print_param_value_ = a.print_param_value_;
<a name="__line2134"></a>	result.parameters_ = a.parameters_;
<a name="__line2135"></a>	return result;
<a name="__line2136"></a>    }
<a name="__line2137"></a>    function pow(const function &amp;a, const var &amp; exponent)
<a name="__line2138"></a>    {
<a name="__line2139"></a>	return pow(a, function(exponent));
<a name="__line2140"></a>    }
<a name="__line2141"></a>
<a name="__line2142"></a>
<a name="__line2143"></a>    function exp(const function &amp;f)
<a name="__line2144"></a>    {
<a name="__line2145"></a>	if(f.is_constant())
<a name="__line2146"></a>	{
<a name="__line2147"></a>	    vector&lt;var&gt; args, result;
<a name="__line2148"></a>	    f.meval(args,result);
<a name="__line2149"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::exp(result[i].dbl());
<a name="__line2150"></a>	    return result;
<a name="__line2151"></a>	}
<a name="__line2152"></a>	function result;
<a name="__line2153"></a>	result.init_unary_&lt;function_core::Exp&gt;(f);
<a name="__line2154"></a>	return result;
<a name="__line2155"></a>    }
<a name="__line2156"></a>
<a name="__line2157"></a>    function log(const function &amp;f)
<a name="__line2158"></a>    {
<a name="__line2159"></a>	if(f.is_constant())
<a name="__line2160"></a>	{
<a name="__line2161"></a>	    vector&lt;var&gt; args, result;
<a name="__line2162"></a>	    f.meval(args,result);
<a name="__line2163"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::log(result[i].dbl());
<a name="__line2164"></a>	    return result;
<a name="__line2165"></a>	}
<a name="__line2166"></a>	function result;
<a name="__line2167"></a>	result.init_unary_&lt;function_core::Log&gt;(f);
<a name="__line2168"></a>	return result;
<a name="__line2169"></a>    }
<a name="__line2170"></a>
<a name="__line2171"></a>    function log10(const function &amp;f)
<a name="__line2172"></a>    {
<a name="__line2173"></a>	if(f.is_constant())
<a name="__line2174"></a>	{
<a name="__line2175"></a>	    vector&lt;var&gt; args, result;
<a name="__line2176"></a>	    f.meval(args,result);
<a name="__line2177"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::log10(result[i].dbl());
<a name="__line2178"></a>	    return result;
<a name="__line2179"></a>	}
<a name="__line2180"></a>	function result;
<a name="__line2181"></a>	result.init_unary_&lt;function_core::Log10&gt;(f);
<a name="__line2182"></a>	return result;
<a name="__line2183"></a>    }
<a name="__line2184"></a>
<a name="__line2185"></a>    function sin(const function &amp;f)
<a name="__line2186"></a>    {
<a name="__line2187"></a>	if(f.is_constant())
<a name="__line2188"></a>	{
<a name="__line2189"></a>	    vector&lt;var&gt; args, result;
<a name="__line2190"></a>	    f.meval(args,result);
<a name="__line2191"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::sin(result[i].dbl());
<a name="__line2192"></a>	    return result;
<a name="__line2193"></a>	}
<a name="__line2194"></a>	function result;
<a name="__line2195"></a>	result.init_unary_&lt;function_core::Sin&gt;(f);
<a name="__line2196"></a>	return result;
<a name="__line2197"></a>    }
<a name="__line2198"></a>
<a name="__line2199"></a>    function asin(const function &amp;f)
<a name="__line2200"></a>    {
<a name="__line2201"></a>        if(f.is_constant())
<a name="__line2202"></a>        {
<a name="__line2203"></a>	    vector&lt;var&gt; args, result;
<a name="__line2204"></a>	    f.meval(args,result);
<a name="__line2205"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::asin(result[i].dbl());
<a name="__line2206"></a>	    return result;
<a name="__line2207"></a>        }
<a name="__line2208"></a>	function result;
<a name="__line2209"></a>	result.init_unary_&lt;function_core::Asin&gt;(f);
<a name="__line2210"></a>	return result;
<a name="__line2211"></a>    }
<a name="__line2212"></a>
<a name="__line2213"></a>    function cos(const function &amp;f)
<a name="__line2214"></a>    {
<a name="__line2215"></a>	if(f.is_constant())
<a name="__line2216"></a>	{
<a name="__line2217"></a>	    vector&lt;var&gt; args, result;
<a name="__line2218"></a>	    f.meval(args,result);
<a name="__line2219"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::cos(result[i].dbl());
<a name="__line2220"></a>	    return result;
<a name="__line2221"></a>	}
<a name="__line2222"></a>	function result;
<a name="__line2223"></a>	result.init_unary_&lt;function_core::Cos&gt;(f);
<a name="__line2224"></a>	return result;
<a name="__line2225"></a>    }
<a name="__line2226"></a>
<a name="__line2227"></a>    function acos(const function &amp;f)
<a name="__line2228"></a>    {
<a name="__line2229"></a>        if(f.is_constant())
<a name="__line2230"></a>        {
<a name="__line2231"></a>	    vector&lt;var&gt; args, result;
<a name="__line2232"></a>	    f.meval(args,result);
<a name="__line2233"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::acos(result[i].dbl());
<a name="__line2234"></a>	    return result;
<a name="__line2235"></a>        }
<a name="__line2236"></a>	function result;
<a name="__line2237"></a>	result.init_unary_&lt;function_core::Acos&gt;(f);
<a name="__line2238"></a>	return result;
<a name="__line2239"></a>    }
<a name="__line2240"></a>
<a name="__line2241"></a>    function tan(const function &amp;f)
<a name="__line2242"></a>    {
<a name="__line2243"></a>	if(f.is_constant())
<a name="__line2244"></a>	{
<a name="__line2245"></a>	    vector&lt;var&gt; args, result;
<a name="__line2246"></a>	    f.meval(args,result);
<a name="__line2247"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::tan(result[i].dbl());
<a name="__line2248"></a>	    return result;
<a name="__line2249"></a>	}
<a name="__line2250"></a>	function result;
<a name="__line2251"></a>	result.init_unary_&lt;function_core::Tan&gt;(f);
<a name="__line2252"></a>	return result;
<a name="__line2253"></a>    }
<a name="__line2254"></a>
<a name="__line2255"></a>    function atan(const function &amp;f)
<a name="__line2256"></a>    {
<a name="__line2257"></a>	if(f.is_constant())
<a name="__line2258"></a>	{
<a name="__line2259"></a>	    vector&lt;var&gt; args, result;
<a name="__line2260"></a>	    f.meval(args,result);
<a name="__line2261"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::atan(result[i].dbl());
<a name="__line2262"></a>	    return result;
<a name="__line2263"></a>	}
<a name="__line2264"></a>	function result;
<a name="__line2265"></a>	result.init_unary_&lt;function_core::Atan&gt;(f);
<a name="__line2266"></a>	return result;
<a name="__line2267"></a>    }
<a name="__line2268"></a>
<a name="__line2269"></a>    function cot(const function &amp;f)
<a name="__line2270"></a>    {
<a name="__line2271"></a>	function result;
<a name="__line2272"></a>	result.init_unary_&lt;function_core::Cot&gt;(f);
<a name="__line2273"></a>	return result;
<a name="__line2274"></a>    }
<a name="__line2275"></a>
<a name="__line2276"></a>    function acot(const function &amp;f)
<a name="__line2277"></a>    {
<a name="__line2278"></a>	function result;
<a name="__line2279"></a>	result.init_unary_&lt;function_core::Acot&gt;(f);
<a name="__line2280"></a>	return result;
<a name="__line2281"></a>    }
<a name="__line2282"></a>
<a name="__line2283"></a>    function sinh(const function &amp;f)
<a name="__line2284"></a>    {
<a name="__line2285"></a>	if(f.is_constant())
<a name="__line2286"></a>	{
<a name="__line2287"></a>	    vector&lt;var&gt; args, result;
<a name="__line2288"></a>	    f.meval(args,result);
<a name="__line2289"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::sinh(result[i].dbl());
<a name="__line2290"></a>	    return result;
<a name="__line2291"></a>	}
<a name="__line2292"></a>	function result;
<a name="__line2293"></a>	result.init_unary_&lt;function_core::Sinh&gt;(f);
<a name="__line2294"></a>	return result;
<a name="__line2295"></a>    }
<a name="__line2296"></a>
<a name="__line2297"></a>    function cosh(const function &amp;f)
<a name="__line2298"></a>    {
<a name="__line2299"></a>	if(f.is_constant())
<a name="__line2300"></a>	{
<a name="__line2301"></a>	    vector&lt;var&gt; args, result;
<a name="__line2302"></a>	    f.meval(args,result);
<a name="__line2303"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::cosh(result[i].dbl());
<a name="__line2304"></a>	    return result;
<a name="__line2305"></a>	}
<a name="__line2306"></a>	function result;
<a name="__line2307"></a>	result.init_unary_&lt;function_core::Cosh&gt;(f);
<a name="__line2308"></a>	return result;
<a name="__line2309"></a>    }
<a name="__line2310"></a>
<a name="__line2311"></a>    function tanh(const function &amp;f)
<a name="__line2312"></a>    {
<a name="__line2313"></a>	if(f.is_constant())
<a name="__line2314"></a>	{
<a name="__line2315"></a>	    vector&lt;var&gt; args, result;
<a name="__line2316"></a>	    f.meval(args,result);
<a name="__line2317"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::tanh(result[i].dbl());
<a name="__line2318"></a>	    return result;
<a name="__line2319"></a>	}
<a name="__line2320"></a>	function result;
<a name="__line2321"></a>	result.init_unary_&lt;function_core::Tanh&gt;(f);
<a name="__line2322"></a>	return result;
<a name="__line2323"></a>    }
<a name="__line2324"></a>
<a name="__line2325"></a>    function atanh(const function &amp;f)
<a name="__line2326"></a>    {
<a name="__line2327"></a>	if(f.is_constant())
<a name="__line2328"></a>	{
<a name="__line2329"></a>	    vector&lt;var&gt; args, result;
<a name="__line2330"></a>	    f.meval(args,result);
<a name="__line2331"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::atanh(result[i].dbl());
<a name="__line2332"></a>	    return result;
<a name="__line2333"></a>	}
<a name="__line2334"></a>	function result;
<a name="__line2335"></a>	result.init_unary_&lt;function_core::Atanh&gt;(f);
<a name="__line2336"></a>	return result;
<a name="__line2337"></a>    }
<a name="__line2338"></a>
<a name="__line2339"></a>    function asinh(const function &amp;f)
<a name="__line2340"></a>    {
<a name="__line2341"></a>	if(f.is_constant())
<a name="__line2342"></a>	{
<a name="__line2343"></a>	    vector&lt;var&gt; args, result;
<a name="__line2344"></a>	    f.meval(args,result);
<a name="__line2345"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::asinh(result[i].dbl());
<a name="__line2346"></a>	    return result;
<a name="__line2347"></a>	}
<a name="__line2348"></a>	function result;
<a name="__line2349"></a>	result.init_unary_&lt;function_core::Asinh&gt;(f);
<a name="__line2350"></a>	return result;
<a name="__line2351"></a>    }
<a name="__line2352"></a>
<a name="__line2353"></a>    function acosh(const function &amp;f)
<a name="__line2354"></a>    {
<a name="__line2355"></a>	if(f.is_constant())
<a name="__line2356"></a>	{
<a name="__line2357"></a>	    vector&lt;var&gt; args, result;
<a name="__line2358"></a>	    f.meval(args,result);
<a name="__line2359"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::acosh(result[i].dbl());
<a name="__line2360"></a>	    return result;
<a name="__line2361"></a>	}
<a name="__line2362"></a>	function result;
<a name="__line2363"></a>	result.init_unary_&lt;function_core::Acosh&gt;(f);
<a name="__line2364"></a>	return result;
<a name="__line2365"></a>    }
<a name="__line2366"></a>
<a name="__line2367"></a>    function floor(const function &amp;f)
<a name="__line2368"></a>    {
<a name="__line2369"></a>	if(f.is_constant())
<a name="__line2370"></a>	{
<a name="__line2371"></a>	    vector&lt;var&gt; args, result;
<a name="__line2372"></a>	    f.meval(args,result);
<a name="__line2373"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::floor(result[i].dbl());
<a name="__line2374"></a>	    return result;
<a name="__line2375"></a>	}
<a name="__line2376"></a>	function result;
<a name="__line2377"></a>	result.init_unary_&lt;function_core::Floor&gt;(f);
<a name="__line2378"></a>	return result;
<a name="__line2379"></a>    }
<a name="__line2380"></a>
<a name="__line2381"></a>    function ceil(const function &amp;f)
<a name="__line2382"></a>    {
<a name="__line2383"></a>	if(f.is_constant())
<a name="__line2384"></a>	{
<a name="__line2385"></a>	    vector&lt;var&gt; args, result;
<a name="__line2386"></a>	    f.meval(args,result);
<a name="__line2387"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::ceil(result[i].dbl());
<a name="__line2388"></a>	    return result;
<a name="__line2389"></a>	}
<a name="__line2390"></a>	function result;
<a name="__line2391"></a>	result.init_unary_&lt;function_core::Ceil&gt;(f);
<a name="__line2392"></a>	return result;
<a name="__line2393"></a>    }
<a name="__line2394"></a>
<a name="__line2395"></a>    function round(const function &amp;f)
<a name="__line2396"></a>    {
<a name="__line2397"></a>	if(f.is_constant())
<a name="__line2398"></a>	{
<a name="__line2399"></a>	    vector&lt;var&gt; args, result;
<a name="__line2400"></a>	    f.meval(args,result);
<a name="__line2401"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::round(result[i].dbl());
<a name="__line2402"></a>	    return result;
<a name="__line2403"></a>	}
<a name="__line2404"></a>	function result;
<a name="__line2405"></a>	result.init_unary_&lt;function_core::Round&gt;(f);
<a name="__line2406"></a>	return result;
<a name="__line2407"></a>    }
<a name="__line2408"></a>
<a name="__line2409"></a>
<a name="__line2410"></a>    function erf(const function &amp;f)
<a name="__line2411"></a>    {
<a name="__line2412"></a>	if(f.is_constant())
<a name="__line2413"></a>	{
<a name="__line2414"></a>	    vector&lt;var&gt; args, result;
<a name="__line2415"></a>	    f.meval(args,result);
<a name="__line2416"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::erf(result[i].dbl());
<a name="__line2417"></a>	    return result;
<a name="__line2418"></a>	}
<a name="__line2419"></a>	function result;
<a name="__line2420"></a>	result.init_unary_&lt;function_core::Erf&gt;(f);
<a name="__line2421"></a>	return result;
<a name="__line2422"></a>    }	 
<a name="__line2423"></a>
<a name="__line2424"></a>    function sign(const function &amp;f)
<a name="__line2425"></a>    {
<a name="__line2426"></a>	if(f.is_constant())
<a name="__line2427"></a>	{
<a name="__line2428"></a>	    vector&lt;var&gt; args, result;
<a name="__line2429"></a>	    f.meval(args,result);
<a name="__line2430"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i)
<a name="__line2431"></a>	    {
<a name="__line2432"></a>		if(result[i].dbl()&gt;0) result[i] = 1;
<a name="__line2433"></a>		else if(result[i].dbl()&lt;0) result[i] = -1;
<a name="__line2434"></a>		else result[i] = 0;
<a name="__line2435"></a>	    }
<a name="__line2436"></a>	    return result;
<a name="__line2437"></a>	}
<a name="__line2438"></a>	function result;
<a name="__line2439"></a>	result.init_unary_&lt;function_core::Sign&gt;(f);
<a name="__line2440"></a>	return result;
<a name="__line2441"></a>    }
<a name="__line2442"></a>
<a name="__line2443"></a>    function abs(const function &amp;f)
<a name="__line2444"></a>    {
<a name="__line2445"></a>	if(f.is_constant())
<a name="__line2446"></a>	{
<a name="__line2447"></a>	    vector&lt;var&gt; args, result;
<a name="__line2448"></a>	    f.meval(args,result);
<a name="__line2449"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::fabs(result[i].dbl());
<a name="__line2450"></a>	    return result;
<a name="__line2451"></a>	}
<a name="__line2452"></a>	function result;
<a name="__line2453"></a>	result.init_unary_&lt;function_core::Abs&gt;(f);
<a name="__line2454"></a>	return result;
<a name="__line2455"></a>    }
<a name="__line2456"></a>    function fabs(const function &amp;f)
<a name="__line2457"></a>    {
<a name="__line2458"></a>	if(f.is_constant())
<a name="__line2459"></a>	{
<a name="__line2460"></a>	    vector&lt;var&gt; args, result;
<a name="__line2461"></a>	    f.meval(args,result);
<a name="__line2462"></a>	    for(unsigned int i=0; i&lt;result.size(); ++i) result[i] = ::fabs(result[i].dbl());
<a name="__line2463"></a>	    return result;
<a name="__line2464"></a>	}
<a name="__line2465"></a>	function result;
<a name="__line2466"></a>	result.init_unary_&lt;function_core::Abs&gt;(f);
<a name="__line2467"></a>	return result;
<a name="__line2468"></a>    }
<a name="__line2469"></a>    function periodic_function(const function &amp;f, double x1, double x2)
<a name="__line2470"></a>    {
<a name="__line2471"></a>	if(f.is_constant())
<a name="__line2472"></a>	{
<a name="__line2473"></a>	    vector&lt;var&gt; args, result;
<a name="__line2474"></a>	    f.meval(args,result);
<a name="__line2475"></a>	    return result;
<a name="__line2476"></a>	}
<a name="__line2477"></a>        return new function_core::periodic(f.base_,x1,x2);
<a name="__line2478"></a>    }
<a name="__line2479"></a>    function periodic_function(const function &amp;f, double x1, double x2, double y1, double y2)
<a name="__line2480"></a>    {
<a name="__line2481"></a>	if(f.is_constant())
<a name="__line2482"></a>	{
<a name="__line2483"></a>	    vector&lt;var&gt; args, result;
<a name="__line2484"></a>	    f.meval(args,result);
<a name="__line2485"></a>	    return result;
<a name="__line2486"></a>	}
<a name="__line2487"></a>        return new function_core::periodic(f.base_,x1,x2,y1,y2);
<a name="__line2488"></a>    }
<a name="__line2489"></a>    function periodic_function(const function &amp;f, double x1, double x2, double y1, double y2, double z1, double z2)
<a name="__line2490"></a>    {
<a name="__line2491"></a>	if(f.is_constant())
<a name="__line2492"></a>	{
<a name="__line2493"></a>	    vector&lt;var&gt; args, result;
<a name="__line2494"></a>	    f.meval(args,result);
<a name="__line2495"></a>	    return result;
<a name="__line2496"></a>	}
<a name="__line2497"></a>        return new function_core::periodic(f.base_,x1,x2,y1,y2,z1,z2);
<a name="__line2498"></a>    }
<a name="__line2499"></a>
<a name="__line2500"></a>    function ifelse(const function &amp;condition, const function &amp;iftrue, const function &amp;iffalse)
<a name="__line2501"></a>    {
<a name="__line2502"></a>	return new function_core::ifelse(condition,iftrue,iffalse);
<a name="__line2503"></a>    }
<a name="__line2504"></a>
<a name="__line2505"></a>    function join_args(const function &amp;separator, const function &amp;from, const function &amp;to)
<a name="__line2506"></a>    {
<a name="__line2507"></a>        return new function_core::join_args(separator,from,to);
<a name="__line2508"></a>    }
<a name="__line2509"></a>
<a name="__line2510"></a>#ifdef HAVE_GSL
<a name="__line2511"></a>
<a name="__line2512"></a>    function bessel_J(int nu, const function &amp;a)
<a name="__line2513"></a>    {
<a name="__line2514"></a>	function result;
<a name="__line2515"></a>	bessel::setup_bessel_core(nu, a, bessel::J, result);
<a name="__line2516"></a>	return result;
<a name="__line2517"></a>    }
<a name="__line2518"></a>    function bessel_Y(int nu, const function &amp;a)
<a name="__line2519"></a>    {
<a name="__line2520"></a>	function result;
<a name="__line2521"></a>	bessel::setup_bessel_core(nu, a, bessel::Y, result);
<a name="__line2522"></a>	return result;
<a name="__line2523"></a>    }
<a name="__line2524"></a>    function bessel_I(int nu, const function &amp;a)
<a name="__line2525"></a>    {
<a name="__line2526"></a>	function result;
<a name="__line2527"></a>	bessel::setup_bessel_core(nu, a, bessel::I, result);
<a name="__line2528"></a>	return result;
<a name="__line2529"></a>    }
<a name="__line2530"></a>    function bessel_K(int nu, const function &amp;a)
<a name="__line2531"></a>    {
<a name="__line2532"></a>	function result;
<a name="__line2533"></a>	bessel::setup_bessel_core(nu, a, bessel::K, result);
<a name="__line2534"></a>	return result;
<a name="__line2535"></a>    }
<a name="__line2536"></a>    function bessel_j(int nu, const function &amp;a)
<a name="__line2537"></a>    {
<a name="__line2538"></a>	function result;
<a name="__line2539"></a>	bessel::setup_bessel_core(nu, a, bessel::j, result);
<a name="__line2540"></a>	return result;
<a name="__line2541"></a>    }
<a name="__line2542"></a>    function bessel_y(int nu, const function &amp;a)
<a name="__line2543"></a>    {
<a name="__line2544"></a>	function result;
<a name="__line2545"></a>	bessel::setup_bessel_core(nu, a, bessel::y, result);
<a name="__line2546"></a>	return result;
<a name="__line2547"></a>    }
<a name="__line2548"></a>    function bessel_i_scaled(int nu, const function &amp;a)
<a name="__line2549"></a>    {
<a name="__line2550"></a>	function result;
<a name="__line2551"></a>	bessel::setup_bessel_core(nu, a, bessel::i_scaled, result);
<a name="__line2552"></a>	return result;
<a name="__line2553"></a>    }
<a name="__line2554"></a>    function bessel_k_scaled(int nu, const function &amp;a)
<a name="__line2555"></a>    {
<a name="__line2556"></a>	function result;
<a name="__line2557"></a>	bessel::setup_bessel_core(nu, a, bessel::k_scaled, result);
<a name="__line2558"></a>	return result;
<a name="__line2559"></a>    }
<a name="__line2560"></a>
<a name="__line2561"></a>
<a name="__line2562"></a>
<a name="__line2563"></a>
<a name="__line2564"></a>    double bessel_J(int n, double x)
<a name="__line2565"></a>    {
<a name="__line2566"></a>	if(n==0) return gsl_sf_bessel_J0(x);
<a name="__line2567"></a>	if(n==1) return gsl_sf_bessel_J1(x);
<a name="__line2568"></a>	return gsl_sf_bessel_Jn(n,x);
<a name="__line2569"></a>    }
<a name="__line2570"></a>    double bessel_Y(int n, double x)
<a name="__line2571"></a>    {
<a name="__line2572"></a>	if(n==0) return gsl_sf_bessel_Y0(x);
<a name="__line2573"></a>	if(n==1) return gsl_sf_bessel_Y1(x);
<a name="__line2574"></a>	return gsl_sf_bessel_Yn(n,x);
<a name="__line2575"></a>    }
<a name="__line2576"></a>    double bessel_I(int n, double x)
<a name="__line2577"></a>    {
<a name="__line2578"></a>	if(n==0) return gsl_sf_bessel_I0(x);
<a name="__line2579"></a>	if(n==1) return gsl_sf_bessel_I1(x);
<a name="__line2580"></a>	return gsl_sf_bessel_In(n,x);
<a name="__line2581"></a>    }
<a name="__line2582"></a>    double bessel_K(int n, double x)
<a name="__line2583"></a>    {
<a name="__line2584"></a>	if(n==0) return gsl_sf_bessel_K0(x);
<a name="__line2585"></a>	if(n==1) return gsl_sf_bessel_K1(x);
<a name="__line2586"></a>	return gsl_sf_bessel_Kn(n,x);
<a name="__line2587"></a>    }
<a name="__line2588"></a>    double bessel_j(int n, double x)
<a name="__line2589"></a>    {
<a name="__line2590"></a>	if(n==0) return gsl_sf_bessel_j0(x);
<a name="__line2591"></a>	if(n==1) return gsl_sf_bessel_j1(x);
<a name="__line2592"></a>	if(n==2) return gsl_sf_bessel_j2(x);
<a name="__line2593"></a>	return gsl_sf_bessel_jl(n,x);
<a name="__line2594"></a>    }
<a name="__line2595"></a>    double bessel_y(int n, double x)
<a name="__line2596"></a>    {
<a name="__line2597"></a>	if(n==0) return gsl_sf_bessel_y0(x);
<a name="__line2598"></a>	if(n==1) return gsl_sf_bessel_y1(x);
<a name="__line2599"></a>	if(n==2) return gsl_sf_bessel_y2(x);
<a name="__line2600"></a>	return gsl_sf_bessel_yl(n,x);
<a name="__line2601"></a>    }
<a name="__line2602"></a>    double bessel_i_scaled(int n, double x)
<a name="__line2603"></a>    {
<a name="__line2604"></a>	if(n==0) return gsl_sf_bessel_i0_scaled(x);
<a name="__line2605"></a>	if(n==1) return gsl_sf_bessel_i1_scaled(x);
<a name="__line2606"></a>	if(n==2) return gsl_sf_bessel_i2_scaled(x);
<a name="__line2607"></a>	return gsl_sf_bessel_il_scaled(n,x);
<a name="__line2608"></a>    }
<a name="__line2609"></a>    double bessel_k_scaled(int n, double x)
<a name="__line2610"></a>    {
<a name="__line2611"></a>	if(n==0) return gsl_sf_bessel_k0_scaled(x);
<a name="__line2612"></a>	if(n==1) return gsl_sf_bessel_k1_scaled(x);
<a name="__line2613"></a>	if(n==2) return gsl_sf_bessel_k2_scaled(x);
<a name="__line2614"></a>	return gsl_sf_bessel_kl_scaled(n,x);
<a name="__line2615"></a>    }
<a name="__line2616"></a>
<a name="__line2617"></a>    double   bessel_J_zero(int n, int s)
<a name="__line2618"></a>    {
<a name="__line2619"></a>	if(n == 0) return gsl_sf_bessel_zero_J0(s);
<a name="__line2620"></a>	if(n == 1) return gsl_sf_bessel_zero_J1(s);
<a name="__line2621"></a>	return gsl_sf_bessel_zero_Jnu(n,s);
<a name="__line2622"></a>    }
<a name="__line2623"></a>
<a name="__line2624"></a>    double bessel_J_derivative(int n, double x)
<a name="__line2625"></a>    {
<a name="__line2626"></a>	<span class=comment>// http://en.wikipedia.org/wiki/Bessel_function#Derivatives_of_J.2CY.2CI.2CH.2CK</span>
<a name="__line2627"></a>	if(n&gt;=1) return bessel_J(n-1,x)-n/x*bessel_J(n,x);
<a name="__line2628"></a>	return -bessel_J(n+1,x); <span class=comment>//+n/x*bessel_J(n,x);</span>
<a name="__line2629"></a>    }
<a name="__line2630"></a>
<a name="__line2631"></a>    double   bessel_Jprime_zero(int n, int s)
<a name="__line2632"></a>    {
<a name="__line2633"></a>	<span class=comment>// Starting point: for n&gt;=1, the s-th zero of the derivative</span>
<a name="__line2634"></a>	<span class=comment>// is bracketed by the s-1 and s-th zero of the function.</span>
<a name="__line2635"></a>	<span class=comment>// For n==0, the s-th zero is bracked by the s-th and (s+1)-th</span>
<a name="__line2636"></a>	<span class=comment>// zero of the function.</span>
<a name="__line2637"></a>	<span class=comment>// make an interval-division root finding, then interpolate</span>
<a name="__line2638"></a>	<span class=comment>// linearly in the bracketing interval.</span>
<a name="__line2639"></a>	double x1=0,x2=0;
<a name="__line2640"></a>	if(n==0)
<a name="__line2641"></a>	{
<a name="__line2642"></a>	    x1 = bessel_J_zero(0,s);
<a name="__line2643"></a>	    x2 = bessel_J_zero(0,s+1);
<a name="__line2644"></a>	}
<a name="__line2645"></a>	else
<a name="__line2646"></a>	{
<a name="__line2647"></a>	    x2 = bessel_J_zero(n,s);
<a name="__line2648"></a>	    x1  = (s==1?0.1*x2:bessel_J_zero(n,s-1));
<a name="__line2649"></a>	}
<a name="__line2650"></a>
<a name="__line2651"></a>	double y1 = bessel_J_derivative(n,x1);
<a name="__line2652"></a>	double y2 = bessel_J_derivative(n,x2);
<a name="__line2653"></a>	
<a name="__line2654"></a>	if(y1*y2&gt;0)
<a name="__line2655"></a>	{
<a name="__line2656"></a>	    cerr&lt;&lt;"This should not happen in bessel_Jprime_zero("&lt;&lt;n&lt;&lt;","&lt;&lt;s&lt;&lt;")"&lt;&lt;endl;
<a name="__line2657"></a>	    return 0;
<a name="__line2658"></a>	}
<a name="__line2659"></a>
<a name="__line2660"></a>	<span class=comment>// determine the position up to 2^10 precision</span>
<a name="__line2661"></a>	for(int i=0; i&lt;10; ++i)
<a name="__line2662"></a>	{
<a name="__line2663"></a>	    <span class=comment>// take midpoint of interval</span>
<a name="__line2664"></a>	    const double x = 0.5*(x1+x2);
<a name="__line2665"></a>	    const double y = bessel_J_derivative(n,x);
<a name="__line2666"></a>
<a name="__line2667"></a>	    if(y*y2&lt;0)
<a name="__line2668"></a>	    {
<a name="__line2669"></a>		x1 = x;
<a name="__line2670"></a>		y1 = y;
<a name="__line2671"></a>	    }
<a name="__line2672"></a>	    else
<a name="__line2673"></a>	    {
<a name="__line2674"></a>		x2 = x;
<a name="__line2675"></a>		y2 = y;
<a name="__line2676"></a>	    }
<a name="__line2677"></a>	}
<a name="__line2678"></a>
<a name="__line2679"></a>	return (x1*y2-x2*y1)/(y2-y1);
<a name="__line2680"></a>    }
<a name="__line2681"></a>
<a name="__line2682"></a>#endif
<a name="__line2683"></a>
<a name="__line2684"></a>    function between_lines(const function &amp;start, const function &amp;end)
<a name="__line2685"></a>    {
<a name="__line2686"></a>        return new function_core::between_lines(start.base_,end.base_);
<a name="__line2687"></a>    }
<a name="__line2688"></a>
<a name="__line2689"></a>    function charfunc(const function &amp;left, const function &amp;right, bool low_in, bool high_in)
<a name="__line2690"></a>    {
<a name="__line2691"></a>	if(left.components() != right.components()) warning::print("Component mismatch","charfunc");
<a name="__line2692"></a>	function result(new function_core::char_func(left.base_,right.base_,low_in,high_in));
<a name="__line2693"></a>	result.print_param_value_ = (left.print_param_value_ || right.print_param_value_);
<a name="__line2694"></a>	result.parameters_.resize(::max(left.parameters_.size(), right.parameters_.size()));
<a name="__line2695"></a>	unsigned int i=0; 
<a name="__line2696"></a>	for(; i&lt;left .parameters_.size(); ++i) result.parameters_[i] = left .parameters_[i];
<a name="__line2697"></a>	for(; i&lt;right.parameters_.size(); ++i) result.parameters_[i] = right.parameters_[i];
<a name="__line2698"></a>	return result;
<a name="__line2699"></a>    }
<a name="__line2700"></a>
<a name="__line2701"></a>    <span class=comment>// There is some memory leakage here: the previously created</span>
<a name="__line2702"></a>    <span class=comment>// function_core:: base pointers (allocated in</span>
<a name="__line2703"></a>    <span class=comment>// function::global_initializer::gobal_initializer() )</span>
<a name="__line2704"></a>    <span class=comment>// are not freed, and they are lost</span>
<a name="__line2705"></a>    function _0(new function_core::named_param("linenumber"));
<a name="__line2706"></a>    function _b(new function_core::named_param("blocknumber"));
<a name="__line2707"></a>    function _B(new function_core::named_param("Blocknumber"));
<a name="__line2708"></a>    function _g(new function_core::named_param("groupingvalue"));
<a name="__line2709"></a>    function _1(new function_core::arg(1));
<a name="__line2710"></a>    function _2(new function_core::arg(2));
<a name="__line2711"></a>    function _3(new function_core::arg(3));
<a name="__line2712"></a>    function _4(new function_core::arg(4));
<a name="__line2713"></a>    function _5(new function_core::arg(5));
<a name="__line2714"></a>    function _6(new function_core::arg(6));
<a name="__line2715"></a>    function _7(new function_core::arg(7));
<a name="__line2716"></a>    function _8(new function_core::arg(8));
<a name="__line2717"></a>    function _9(new function_core::arg(9));
<a name="__line2718"></a>    function _10(new function_core::arg(10));
<a name="__line2719"></a>    function _11(new function_core::arg(11));
<a name="__line2720"></a>    function _12(new function_core::arg(12));
<a name="__line2721"></a>    function _13(new function_core::arg(13));
<a name="__line2722"></a>    function _14(new function_core::arg(14));
<a name="__line2723"></a>    function _15(new function_core::arg(15));
<a name="__line2724"></a>    function _16(new function_core::arg(16));
<a name="__line2725"></a>    function _17(new function_core::arg(17));
<a name="__line2726"></a>    function _18(new function_core::arg(18));
<a name="__line2727"></a>    function _19(new function_core::arg(19));
<a name="__line2728"></a>    function _20(new function_core::arg(20));
<a name="__line2729"></a>    function _21(new function_core::arg(21));
<a name="__line2730"></a>    function _22(new function_core::arg(22));
<a name="__line2731"></a>    function _23(new function_core::arg(23));
<a name="__line2732"></a>    function _24(new function_core::arg(24));
<a name="__line2733"></a>    function _25(new function_core::arg(25));
<a name="__line2734"></a>    function _26(new function_core::arg(26));
<a name="__line2735"></a>    function _27(new function_core::arg(27));
<a name="__line2736"></a>    function _28(new function_core::arg(28));
<a name="__line2737"></a>    function _29(new function_core::arg(29));
<a name="__line2738"></a>    function _30(new function_core::arg(30));
<a name="__line2739"></a>    function _N(new function_core::actual_nargs);
<a name="__line2740"></a>    function _n(const var &amp;id) { return new function_core::named_param(id); }
<a name="__line2741"></a>
<a name="__line2742"></a>    function ARG(int i) {return function_core::arg(i);}
<a name="__line2743"></a>    function PAR(int i) {return function_core::funcparameter(i);}
<a name="__line2744"></a>
<a name="__line2745"></a>    <span class=comment>// Returns a function which buffers its calling arguments from previous calls, </span>
<a name="__line2746"></a>    <span class=comment>// and returns the arguments from the nth previous call</span>
<a name="__line2747"></a>    function PREV(int n) { return function_core::prev(n); }
<a name="__line2748"></a>
<a name="__line2749"></a>    bool function::initialized() const
<a name="__line2750"></a>    {
<a name="__line2751"></a>	return base_ != 0;
<a name="__line2752"></a>    }
<a name="__line2753"></a>
<a name="__line2754"></a>    bool function::is_constant() const
<a name="__line2755"></a>    {
<a name="__line2756"></a>	if(!initialized()) return false;
<a name="__line2757"></a>	return base_-&gt;is_constant();
<a name="__line2758"></a>    }
<a name="__line2759"></a>
<a name="__line2760"></a><span class=comment>/*
<a name="__line2761"></a>    function::operator double() const
<a name="__line2762"></a>    {
<a name="__line2763"></a>	if(!is_constant())
<a name="__line2764"></a>	    warning::print("Non-constant function is converted to double. Its value evaluated at 0 is used");
<a name="__line2765"></a>	return operator()(0.0).dbl();
<a name="__line2766"></a>    }
<a name="__line2767"></a>*/</span>
<a name="__line2768"></a>
<a name="__line2769"></a>    const function &amp;function::operator+= (const function &amp;f)
<a name="__line2770"></a>    {
<a name="__line2771"></a>	if(!base_ || !f.base_)
<a name="__line2772"></a>	{
<a name="__line2773"></a>	    warning::print("uninitialized function","function::operator+=");
<a name="__line2774"></a>	    return *this;
<a name="__line2775"></a>	}
<a name="__line2776"></a>
<a name="__line2777"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(f.base_);
<a name="__line2778"></a>	if(c2 &amp;&amp; c2-&gt;value_ == 0.0) return *this;
<a name="__line2779"></a>
<a name="__line2780"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(base_);
<a name="__line2781"></a>	if(c1 &amp;&amp; c1-&gt;value_ == 0.0)
<a name="__line2782"></a>	{
<a name="__line2783"></a>	    delete base_;
<a name="__line2784"></a>	    base_ = f.base_-&gt;clone();
<a name="__line2785"></a>	    return *this;
<a name="__line2786"></a>	}
<a name="__line2787"></a>	
<a name="__line2788"></a>	function_core::Add *add = new function_core::Add;
<a name="__line2789"></a>	add-&gt;left(base_);
<a name="__line2790"></a>	add-&gt;right(f.base_-&gt;clone());
<a name="__line2791"></a>	base_ = add;
<a name="__line2792"></a>
<a name="__line2793"></a>	return *this;
<a name="__line2794"></a>    }
<a name="__line2795"></a>
<a name="__line2796"></a>    const function &amp;function::operator-= (const function &amp;f)
<a name="__line2797"></a>    {
<a name="__line2798"></a>	if(!base_ || !f.base_)
<a name="__line2799"></a>	{
<a name="__line2800"></a>	    warning::print("uninitialized function","function::operator-=");
<a name="__line2801"></a>	    return *this;
<a name="__line2802"></a>	}
<a name="__line2803"></a>
<a name="__line2804"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(f.base_);
<a name="__line2805"></a>	if(c2 &amp;&amp; c2-&gt;value_ == 0.0) return *this;
<a name="__line2806"></a>
<a name="__line2807"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(base_);
<a name="__line2808"></a>	if(c1 &amp;&amp; c1-&gt;value_ == 0.0)
<a name="__line2809"></a>	{
<a name="__line2810"></a>	    function_core::Neg *neg = new function_core::Neg;
<a name="__line2811"></a>	    neg-&gt;operand(base_);
<a name="__line2812"></a>	    base_ = neg;
<a name="__line2813"></a>	    return *this;
<a name="__line2814"></a>	}
<a name="__line2815"></a>	
<a name="__line2816"></a>	function_core::Sub *sub = new function_core::Sub;
<a name="__line2817"></a>	sub-&gt;left(base_);
<a name="__line2818"></a>	sub-&gt;right(f.base_-&gt;clone());
<a name="__line2819"></a>	base_ = sub;
<a name="__line2820"></a>
<a name="__line2821"></a>	return *this;
<a name="__line2822"></a>    }
<a name="__line2823"></a>
<a name="__line2824"></a>    const function &amp;function::operator*= (const function &amp;f)
<a name="__line2825"></a>    {
<a name="__line2826"></a>	if(!base_ || !f.base_)
<a name="__line2827"></a>	{
<a name="__line2828"></a>	    warning::print("uninitialized function","function::operator*=");
<a name="__line2829"></a>	    return *this;
<a name="__line2830"></a>	}
<a name="__line2831"></a>
<a name="__line2832"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(f.base_);
<a name="__line2833"></a>	if(c2 &amp;&amp; c2-&gt;value_ == 0.0)
<a name="__line2834"></a>	{
<a name="__line2835"></a>	    delete base_;
<a name="__line2836"></a>	    base_ = new constant(0.0);
<a name="__line2837"></a>	    return *this;
<a name="__line2838"></a>	}
<a name="__line2839"></a>	if(c2 &amp;&amp; c2-&gt;value_ == 1.0) return *this;
<a name="__line2840"></a>
<a name="__line2841"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(base_);
<a name="__line2842"></a>	if(c1 &amp;&amp; c1-&gt;value_ == 0.0) return *this;
<a name="__line2843"></a>	if(c1 &amp;&amp; c1-&gt;value_ == 1.0)
<a name="__line2844"></a>	{
<a name="__line2845"></a>	    delete base_;
<a name="__line2846"></a>	    base_ = f.base_-&gt;clone();
<a name="__line2847"></a>	    return *this;
<a name="__line2848"></a>	}
<a name="__line2849"></a>	
<a name="__line2850"></a>	function_core::Mul *mul = new function_core::Mul;
<a name="__line2851"></a>	mul-&gt;left(base_);
<a name="__line2852"></a>	mul-&gt;right(f.base_-&gt;clone());
<a name="__line2853"></a>	base_ = mul;
<a name="__line2854"></a>
<a name="__line2855"></a>	return *this;
<a name="__line2856"></a>    }
<a name="__line2857"></a>
<a name="__line2858"></a>    const function &amp;function::operator/= (const function &amp;f)
<a name="__line2859"></a>    {
<a name="__line2860"></a>	if(!base_ || !f.base_)
<a name="__line2861"></a>	{
<a name="__line2862"></a>	    warning::print("uninitialized function","function::operator*=");
<a name="__line2863"></a>	    return *this;
<a name="__line2864"></a>	}
<a name="__line2865"></a>
<a name="__line2866"></a>	function_core::constant *c2 = dynamic_cast&lt;constant *&gt;(f.base_);
<a name="__line2867"></a>	if(c2 &amp;&amp; c2-&gt;value_ == 1.0) return *this;
<a name="__line2868"></a>
<a name="__line2869"></a>	function_core::constant *c1 = dynamic_cast&lt;constant *&gt;(base_);
<a name="__line2870"></a>	if(c1 &amp;&amp; c1-&gt;value_ == 0.0) return *this;
<a name="__line2871"></a>	
<a name="__line2872"></a>	function_core::Div *div = new function_core::Div;
<a name="__line2873"></a>	div-&gt;left(base_);
<a name="__line2874"></a>	div-&gt;right(f.base_-&gt;clone());
<a name="__line2875"></a>	base_ = div;
<a name="__line2876"></a>
<a name="__line2877"></a>	return *this;
<a name="__line2878"></a>    }
<a name="__line2879"></a>
<a name="__line2880"></a>    function random()
<a name="__line2881"></a>    {
<a name="__line2882"></a>	return new function_core::random;
<a name="__line2883"></a>    }
<a name="__line2884"></a>    function random(double to)
<a name="__line2885"></a>    {
<a name="__line2886"></a>	return new function_core::random(0,to);
<a name="__line2887"></a>    }
<a name="__line2888"></a>    function random(double from, double to)
<a name="__line2889"></a>    {
<a name="__line2890"></a>	return new function_core::random(from,to);
<a name="__line2891"></a>    }
<a name="__line2892"></a>    function random_gauss(double a, double s, int parameter_index)
<a name="__line2893"></a>    {
<a name="__line2894"></a>	function result;
<a name="__line2895"></a>	if(parameter_index&gt;0)
<a name="__line2896"></a>	{
<a name="__line2897"></a>	    result =
<a name="__line2898"></a>		PAR(parameter_index)+
<a name="__line2899"></a>		PAR(parameter_index+1)*sqrt(2.0*fabs(log(1.0-blop::random(0.0, 1.0))))*
<a name="__line2900"></a>		cos((2.0*M_PI)*blop::random(0.0, 1.0));
<a name="__line2901"></a>	    result.param(parameter_index,1);
<a name="__line2902"></a>	    result.param(parameter_index+1,s);
<a name="__line2903"></a>	}
<a name="__line2904"></a>	else
<a name="__line2905"></a>	{
<a name="__line2906"></a>	    result =
<a name="__line2907"></a>		a+
<a name="__line2908"></a>		s*sqrt(2.0*fabs(log(1.0-blop::random(0.0, 1.0))))*
<a name="__line2909"></a>		cos((2.0*M_PI)*blop::random(0.0, 1.0));
<a name="__line2910"></a>	}
<a name="__line2911"></a>	return result;
<a name="__line2912"></a>    }
<a name="__line2913"></a>    function random_exponential(double d, int parameter_index)
<a name="__line2914"></a>    {
<a name="__line2915"></a>	function result;
<a name="__line2916"></a>	if(parameter_index&gt;0)
<a name="__line2917"></a>	{
<a name="__line2918"></a>	    result = PAR(parameter_index)*log(1.0/(1.0-blop::random(0.0, 1.0)));
<a name="__line2919"></a>	    result.param(parameter_index,d);
<a name="__line2920"></a>	}
<a name="__line2921"></a>	else
<a name="__line2922"></a>	{
<a name="__line2923"></a>	    result = d*log(1.0/(1.0-blop::random(0.0, 1.0)));
<a name="__line2924"></a>	}
<a name="__line2925"></a>	return result;
<a name="__line2926"></a>
<a name="__line2927"></a>    }
<a name="__line2928"></a>    function random_idexponential(double d, int parameter_index)
<a name="__line2929"></a>    {
<a name="__line2930"></a>	function result;
<a name="__line2931"></a>	if(parameter_index&gt;0)
<a name="__line2932"></a>	{
<a name="__line2933"></a>	    result = PAR(parameter_index)*
<a name="__line2934"></a>		log(1.0/((1.0-blop::random(0.0, 1.0))*(1.0-blop::random(0.0, 1.0))));
<a name="__line2935"></a>	    result.param(parameter_index,d);
<a name="__line2936"></a>	}
<a name="__line2937"></a>	else
<a name="__line2938"></a>	{
<a name="__line2939"></a>	    result = d * log(1.0/((1.0-blop::random(0.0, 1.0))*(1.0-blop::random(0.0, 1.0))));
<a name="__line2940"></a>	}
<a name="__line2941"></a>	return result;
<a name="__line2942"></a>    }
<a name="__line2943"></a>
<a name="__line2944"></a>    function &amp;function::derivative(int derivi, const function &amp;d)
<a name="__line2945"></a>    {
<a name="__line2946"></a>	if(!d.initialized())
<a name="__line2947"></a>	{
<a name="__line2948"></a>	    warning::print("Uninitialized function","function::derivative(int,const function &amp;)");
<a name="__line2949"></a>	    return *this;
<a name="__line2950"></a>	}
<a name="__line2951"></a>
<a name="__line2952"></a>	deriv_map::const_iterator iter = derivatives_.find(derivi);
<a name="__line2953"></a>	if(iter != derivatives_.end()) delete (*iter).second;
<a name="__line2954"></a>
<a name="__line2955"></a>	if(components() != d.components())
<a name="__line2956"></a>	{
<a name="__line2957"></a>	    warning::print("Number of components mismatch when setting derivatives",
<a name="__line2958"></a>			   "function::derivative(int,const function &amp;)");
<a name="__line2959"></a>	    return *this;
<a name="__line2960"></a>	}
<a name="__line2961"></a>	derivatives_[derivi] = d.base_-&gt;clone();
<a name="__line2962"></a>	return *this;
<a name="__line2963"></a>    }
<a name="__line2964"></a>
<a name="__line2965"></a>    function function::derivative(int derivindex) const
<a name="__line2966"></a>    {
<a name="__line2967"></a>	if(!base_)
<a name="__line2968"></a>	{
<a name="__line2969"></a>	    warning::print("Uninitialized functions derivative...","function::derivative(in)");
<a name="__line2970"></a>	    return constant(0.0);
<a name="__line2971"></a>	}
<a name="__line2972"></a>
<a name="__line2973"></a>	<span class=comment>// if the user has defined this derivative, return that,</span>
<a name="__line2974"></a>	<span class=comment>// instead of trying to calculate it</span>
<a name="__line2975"></a>	deriv_map::const_iterator iter = derivatives_.find(derivindex);
<a name="__line2976"></a>	if(iter != derivatives_.end())
<a name="__line2977"></a>	{
<a name="__line2978"></a>	    function result(*(*iter).second);
<a name="__line2979"></a>	    result.parameters_ = parameters_;
<a name="__line2980"></a>	    result.print_param_value_ = print_param_value_;
<a name="__line2981"></a>	    return result;
<a name="__line2982"></a>	}
<a name="__line2983"></a>
<a name="__line2984"></a>	function::core *deriv = base_-&gt;create_derivative(derivindex);
<a name="__line2985"></a>
<a name="__line2986"></a>	if(deriv == 0)
<a name="__line2987"></a>	{
<a name="__line2988"></a>	    const int di = -derivindex;
<a name="__line2989"></a>	    string s = "th";
<a name="__line2990"></a>	    if(di == 1) s = "st";
<a name="__line2991"></a>	    if(di == 2) s = "nd";
<a name="__line2992"></a>	    if(di == 3) s = "rd";
<a name="__line2993"></a>	    warning::print(var("Could not calculate ") &amp; di &amp; var(s) &amp; " derivative",
<a name="__line2994"></a>			   "function::derivative(int)");
<a name="__line2995"></a>	    deriv = new constant(0.0);
<a name="__line2996"></a>	}
<a name="__line2997"></a>	function result(deriv);
<a name="__line2998"></a>	result.parameters_ = parameters_;
<a name="__line2999"></a>	result.print_param_value_ = print_param_value_;
<a name="__line3000"></a>	return result;
<a name="__line3001"></a>    }
<a name="__line3002"></a>
<a name="__line3003"></a>
<a name="__line3004"></a>    <span class=comment>// ---------- cfunc  --------------------------------------------------------------</span>
<a name="__line3005"></a>
<a name="__line3006"></a>
<a name="__line3007"></a>    std::ostream &amp;operator&lt;&lt; (std::ostream &amp;out, const blop::function &amp;f)
<a name="__line3008"></a>    {
<a name="__line3009"></a>	f.print(out);
<a name="__line3010"></a>	return out;
<a name="__line3011"></a>    }
<a name="__line3012"></a>
<a name="__line3013"></a>    bool function::default_print_param_value_ = false;
<a name="__line3014"></a>
<a name="__line3015"></a>    function contained_in(const function &amp;f)
<a name="__line3016"></a>    {
<a name="__line3017"></a>	return new function_core::contained_in(f.base_);
<a name="__line3018"></a>    }
<a name="__line3019"></a>
<a name="__line3020"></a>    function function::polynomial(int n)
<a name="__line3021"></a>    {
<a name="__line3022"></a>        function result = PAR(1);
<a name="__line3023"></a>        for(int i=1; i&lt;=n; ++i) result += PAR(i+1)*pow(_1,i);
<a name="__line3024"></a>        return result;
<a name="__line3025"></a>    }
<a name="__line3026"></a>
<a name="__line3027"></a>    function function::interpolate_linear(const var &amp;filename, const function &amp;x, const function &amp;y)
<a name="__line3028"></a>    {
<a name="__line3029"></a>        istream *file = openin(filename);
<a name="__line3030"></a>        if(!file) return unset;
<a name="__line3031"></a>
<a name="__line3032"></a>        bool multidim_x = (x.components()&gt;1);
<a name="__line3033"></a>        bool multidim_y = (y.components()&gt;1);
<a name="__line3034"></a>
<a name="__line3035"></a>        <span class=comment>// If we do a multidimensional interpolation (in x), the file needs to be read twice:</span>
<a name="__line3036"></a>        <span class=comment>// First to get the grid points, and then to store the (x,y) points. That is, if the</span>
<a name="__line3037"></a>        <span class=comment>// input stream is a pipe, copy its content first to a temporary file, so that it can</span>
<a name="__line3038"></a>        <span class=comment>// be processed twice:</span>
<a name="__line3039"></a>        if(dynamic_cast&lt;ipstream*&gt;(file) &amp;&amp; multidim_x)
<a name="__line3040"></a>        {
<a name="__line3041"></a>            string tmpfilename = blop_bookkeeper::tmpfile("ipstream_tmpfile_XXXXXX");
<a name="__line3042"></a>            {
<a name="__line3043"></a>                ofstream otmpfile(tmpfilename.c_str());
<a name="__line3044"></a>                string line;
<a name="__line3045"></a>                while(getline(*file,line)) otmpfile&lt;&lt;line&lt;&lt;endl;
<a name="__line3046"></a>            }
<a name="__line3047"></a>            delete file;
<a name="__line3048"></a>            file = new ifstream(tmpfilename.c_str());
<a name="__line3049"></a>        }
<a name="__line3050"></a>        
<a name="__line3051"></a>        linear_interpolator_md&lt;double,double&gt;                *inter_md_1d = 0;
<a name="__line3052"></a>        linear_interpolator_md&lt;double,valarray&lt;double&gt; &gt;     *inter_md_md = 0;
<a name="__line3053"></a>        linear_interpolator_1d&lt;double,double&gt;                *inter_1d_1d = 0;
<a name="__line3054"></a>        linear_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;     *inter_1d_md = 0;
<a name="__line3055"></a>        
<a name="__line3056"></a>        if(multidim_x)
<a name="__line3057"></a>        {
<a name="__line3058"></a>            if(multidim_y) inter_md_md = new linear_interpolator_md&lt;double,valarray&lt;double&gt; &gt;(x.components());
<a name="__line3059"></a>            else           inter_md_1d = new linear_interpolator_md&lt;double,double&gt;           (x.components());
<a name="__line3060"></a>        }
<a name="__line3061"></a>        else
<a name="__line3062"></a>        {
<a name="__line3063"></a>            if(multidim_y) inter_1d_md = new linear_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;;
<a name="__line3064"></a>            else           inter_1d_1d = new linear_interpolator_1d&lt;double,double&gt;;
<a name="__line3065"></a>        }
<a name="__line3066"></a>        array xxx;
<a name="__line3067"></a>        xxx.resize(x.components());
<a name="__line3068"></a>        array yyy;
<a name="__line3069"></a>        yyy.resize(y.components());
<a name="__line3070"></a>
<a name="__line3071"></a>        array line;
<a name="__line3072"></a>        
<a name="__line3073"></a>        <span class=comment>// For a multidimensional interpolator, one needs to get first all possible gridpoints,</span>
<a name="__line3074"></a>        <span class=comment>// to set up this grid in the interpolator. </span>
<a name="__line3075"></a>        if(multidim_x)
<a name="__line3076"></a>        {
<a name="__line3077"></a>            vector&lt;vector&lt;double&gt; &gt; xvalues(x.components());
<a name="__line3078"></a>            
<a name="__line3079"></a>            <span class=comment>// First loop over the file, to get all the possible gridpoints. </span>
<a name="__line3080"></a>            while(getline(*file,line))
<a name="__line3081"></a>            {
<a name="__line3082"></a>                <span class=comment>// skip empty or commented lines</span>
<a name="__line3083"></a>                if(line.empty()) continue;
<a name="__line3084"></a>                if(dgraph::default_comment_chars().find(line[0][0]) != string::npos) continue;
<a name="__line3085"></a>                <span class=comment>//if(line[0][0]=='#') continue;</span>
<a name="__line3086"></a>                
<a name="__line3087"></a>                x.meval(line,xxx);
<a name="__line3088"></a>                for(unsigned int i=0; i&lt;xxx.size(); ++i)
<a name="__line3089"></a>                {
<a name="__line3090"></a>                    if(find(xvalues[i].begin(),xvalues[i].end(),xxx[i].dbl()) == xvalues[i].end()) xvalues[i].push_back(xxx[i].dbl());
<a name="__line3091"></a>                }
<a name="__line3092"></a>            }
<a name="__line3093"></a>            
<a name="__line3094"></a>            for(unsigned int i=0; i&lt;xvalues.size(); ++i)
<a name="__line3095"></a>            {
<a name="__line3096"></a>                if(inter_md_1d) inter_md_1d-&gt;x(i+1,xvalues[i]);
<a name="__line3097"></a>                if(inter_md_md) inter_md_md-&gt;x(i+1,xvalues[i]);
<a name="__line3098"></a>            }
<a name="__line3099"></a>            
<a name="__line3100"></a>            <span class=comment>// rewind the file to the beginning</span>
<a name="__line3101"></a>            file-&gt;clear();
<a name="__line3102"></a>            file-&gt;seekg(0,ios_base::beg);
<a name="__line3103"></a>        }
<a name="__line3104"></a>        
<a name="__line3105"></a>        vector&lt;double&gt; XXX;
<a name="__line3106"></a>        XXX.resize(xxx.size());
<a name="__line3107"></a>        valarray&lt;double&gt; YYY;
<a name="__line3108"></a>        YYY.resize(yyy.size());
<a name="__line3109"></a>        
<a name="__line3110"></a>        while(getline(*file,line))
<a name="__line3111"></a>        {
<a name="__line3112"></a>            <span class=comment>// skip empty or commented lines</span>
<a name="__line3113"></a>            if(line.empty()) continue;
<a name="__line3114"></a>            if(line[0][0]=='#') continue;
<a name="__line3115"></a>            
<a name="__line3116"></a>            x.meval(line,xxx);
<a name="__line3117"></a>            y.meval(line,yyy);
<a name="__line3118"></a>            
<a name="__line3119"></a>            if(multidim_y)
<a name="__line3120"></a>            {
<a name="__line3121"></a>                for(unsigned int i=0; i&lt;yyy.size(); ++i) YYY[i] = yyy[i].dbl();
<a name="__line3122"></a>            }
<a name="__line3123"></a>        
<a name="__line3124"></a>            if(multidim_x)
<a name="__line3125"></a>            {
<a name="__line3126"></a>                for(unsigned int i=0; i&lt;xxx.size(); ++i) XXX[i] = xxx[i].dbl();
<a name="__line3127"></a>                if(inter_md_1d) inter_md_1d-&gt;y(XXX,yyy[0].dbl());
<a name="__line3128"></a>                if(inter_md_md) inter_md_md-&gt;y(XXX,YYY);
<a name="__line3129"></a>            }
<a name="__line3130"></a>            else
<a name="__line3131"></a>            {
<a name="__line3132"></a>                if(inter_1d_1d) inter_1d_1d-&gt;add_point(xxx[0].dbl(),yyy[0].dbl());
<a name="__line3133"></a>                if(inter_1d_md) inter_1d_md-&gt;add_point(xxx[0].dbl(),YYY);
<a name="__line3134"></a>            }
<a name="__line3135"></a>        }
<a name="__line3136"></a>
<a name="__line3137"></a>        delete file;
<a name="__line3138"></a>
<a name="__line3139"></a><span class=comment>/*
<a name="__line3140"></a>        if(inter_1d_1d) return *inter_1d_1d;
<a name="__line3141"></a>        if(inter_1d_md) return *inter_1d_md;
<a name="__line3142"></a>        if(inter_md_1d) return *inter_md_1d;
<a name="__line3143"></a>        if(inter_md_md) return *inter_md_md;
<a name="__line3144"></a>*/</span>
<a name="__line3145"></a>        if(inter_1d_1d) return inter_1d_1d;
<a name="__line3146"></a>        if(inter_1d_md) return inter_1d_md;
<a name="__line3147"></a>        if(inter_md_1d) return inter_md_1d;
<a name="__line3148"></a>        if(inter_md_md) return inter_md_md;
<a name="__line3149"></a>        warning::print("This should never happen","function::interpolate_linear(filename,x,y)");
<a name="__line3150"></a>        return unset;
<a name="__line3151"></a>    }
<a name="__line3152"></a>
<a name="__line3153"></a>    function function::interpolate_spline(const var &amp;filename, const function &amp;x, const function &amp;y)
<a name="__line3154"></a>    {
<a name="__line3155"></a>        istream *file = openin(filename);
<a name="__line3156"></a>        if(!file) return unset;
<a name="__line3157"></a>        
<a name="__line3158"></a>        if(x.components() != 1)
<a name="__line3159"></a>        {
<a name="__line3160"></a>            warning::print("Spline interpolation can only be done in 1 dimension!");
<a name="__line3161"></a>            delete file;
<a name="__line3162"></a>            return unset;
<a name="__line3163"></a>        }
<a name="__line3164"></a>
<a name="__line3165"></a>        bool multidim_y = (y.components()&gt;1);
<a name="__line3166"></a>        
<a name="__line3167"></a>        spline_interpolator_1d&lt;double,double&gt;                *inter_1d_1d = 0;
<a name="__line3168"></a>        spline_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;     *inter_1d_md = 0;
<a name="__line3169"></a>        
<a name="__line3170"></a>        if(multidim_y) inter_1d_md = new spline_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;;
<a name="__line3171"></a>        else           inter_1d_1d = new spline_interpolator_1d&lt;double,double&gt;;
<a name="__line3172"></a>        
<a name="__line3173"></a>        array yyy;
<a name="__line3174"></a>        yyy.resize(y.components());
<a name="__line3175"></a>        valarray&lt;double&gt; YYY;
<a name="__line3176"></a>        YYY.resize(yyy.size());
<a name="__line3177"></a>        array line;
<a name="__line3178"></a>        
<a name="__line3179"></a>        while(getline(*file,line))
<a name="__line3180"></a>        {
<a name="__line3181"></a>            <span class=comment>// skip empty or commented lines</span>
<a name="__line3182"></a>            if(line.empty()) continue;
<a name="__line3183"></a>            if(line[0][0]=='#') continue;
<a name="__line3184"></a>            
<a name="__line3185"></a>            const double xvalue = x.eval(line).dbl();
<a name="__line3186"></a>            y.meval(line,yyy);
<a name="__line3187"></a>            
<a name="__line3188"></a>            if(multidim_y)
<a name="__line3189"></a>            {
<a name="__line3190"></a>                for(unsigned int i=0; i&lt;yyy.size(); ++i) YYY[i] = yyy[i].dbl();
<a name="__line3191"></a>                if(inter_1d_md) inter_1d_md-&gt;add_point(xvalue,YYY);
<a name="__line3192"></a>            }
<a name="__line3193"></a>            else
<a name="__line3194"></a>            {
<a name="__line3195"></a>                if(inter_1d_1d) inter_1d_1d-&gt;add_point(xvalue,yyy[0].dbl());
<a name="__line3196"></a>            }
<a name="__line3197"></a>        }
<a name="__line3198"></a>
<a name="__line3199"></a>        delete file;
<a name="__line3200"></a><span class=comment>/*
<a name="__line3201"></a>        if(inter_1d_1d) return *inter_1d_1d;
<a name="__line3202"></a>        if(inter_1d_md) return *inter_1d_md;
<a name="__line3203"></a>*/</span>
<a name="__line3204"></a>        if(inter_1d_1d) return inter_1d_1d;
<a name="__line3205"></a>        if(inter_1d_md) return inter_1d_md;
<a name="__line3206"></a>        return unset;
<a name="__line3207"></a>    }
<a name="__line3208"></a>
<a name="__line3209"></a>    function function::interpolate_sppchip(const var &amp;filename, const function &amp;x, const function &amp;y)
<a name="__line3210"></a>    {
<a name="__line3211"></a>        istream *file = openin(filename);
<a name="__line3212"></a>        if(!file) return unset;
<a name="__line3213"></a>        
<a name="__line3214"></a>        if(x.components() != 1)
<a name="__line3215"></a>        {
<a name="__line3216"></a>            delete file;
<a name="__line3217"></a>            warning::print("sppchip interpolation can only be done in 1 dimension!");
<a name="__line3218"></a>            return unset;
<a name="__line3219"></a>        }
<a name="__line3220"></a>
<a name="__line3221"></a>        bool multidim_y = (y.components()&gt;1);
<a name="__line3222"></a>        
<a name="__line3223"></a>        sppchip_interpolator_1d&lt;double,double&gt;                *inter_1d_1d = 0;
<a name="__line3224"></a>        sppchip_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;     *inter_1d_md = 0;
<a name="__line3225"></a>        
<a name="__line3226"></a>        if(multidim_y) inter_1d_md = new sppchip_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;;
<a name="__line3227"></a>        else           inter_1d_1d = new sppchip_interpolator_1d&lt;double,double&gt;;
<a name="__line3228"></a>        
<a name="__line3229"></a>        array yyy;
<a name="__line3230"></a>        yyy.resize(y.components());
<a name="__line3231"></a>        valarray&lt;double&gt; YYY;
<a name="__line3232"></a>        YYY.resize(yyy.size());
<a name="__line3233"></a>        array line;
<a name="__line3234"></a>        
<a name="__line3235"></a>        while(getline(*file,line))
<a name="__line3236"></a>        {
<a name="__line3237"></a>            <span class=comment>// skip empty or commented lines</span>
<a name="__line3238"></a>            if(line.empty()) continue;
<a name="__line3239"></a>            if(line[0][0]=='#') continue;
<a name="__line3240"></a>            
<a name="__line3241"></a>            const double xvalue = x.eval(line).dbl();
<a name="__line3242"></a>            y.meval(line,yyy);
<a name="__line3243"></a>            
<a name="__line3244"></a>            if(multidim_y)
<a name="__line3245"></a>            {
<a name="__line3246"></a>                for(unsigned int i=0; i&lt;yyy.size(); ++i) YYY[i] = yyy[i].dbl();
<a name="__line3247"></a>                if(inter_1d_md) inter_1d_md-&gt;add_point(xvalue,YYY);
<a name="__line3248"></a>            }
<a name="__line3249"></a>            else
<a name="__line3250"></a>            {
<a name="__line3251"></a>                if(inter_1d_1d) inter_1d_1d-&gt;add_point(xvalue,yyy[0].dbl());
<a name="__line3252"></a>            }
<a name="__line3253"></a>        }
<a name="__line3254"></a>
<a name="__line3255"></a>        delete file;
<a name="__line3256"></a><span class=comment>/*
<a name="__line3257"></a>        if(inter_1d_1d) return *inter_1d_1d;
<a name="__line3258"></a>        if(inter_1d_md) return *inter_1d_md;
<a name="__line3259"></a>*/</span>
<a name="__line3260"></a>        if(inter_1d_1d) return inter_1d_1d;
<a name="__line3261"></a>        if(inter_1d_md) return inter_1d_md;
<a name="__line3262"></a>        return unset;
<a name="__line3263"></a>    }
<a name="__line3264"></a>
<a name="__line3265"></a>    function function::interpolate_linear(const plottable &amp;g)
<a name="__line3266"></a>    {
<a name="__line3267"></a>        if(g.columns()&lt;2)
<a name="__line3268"></a>        {
<a name="__line3269"></a>            warning::print("The dgraph must have at least 2 colums","function::interpolate_linear(const dgraph &amp;)");
<a name="__line3270"></a>            return unset;
<a name="__line3271"></a>        }
<a name="__line3272"></a>        if(g.size()&lt;2)
<a name="__line3273"></a>        {
<a name="__line3274"></a>            warning::print("The dgraph must have at least 2 points","function::interpolate_linear(const dgraph &amp;)");
<a name="__line3275"></a>            return unset;
<a name="__line3276"></a>        }
<a name="__line3277"></a>        vector&lt;double&gt; x(g.size()),y(g.size());
<a name="__line3278"></a>        for(unsigned int i=0; i&lt;g.size(); ++i)
<a name="__line3279"></a>        {
<a name="__line3280"></a>            x[i] = (*g.get(i))[0];
<a name="__line3281"></a>            y[i] = (*g.get(i))[1];
<a name="__line3282"></a>            <span class=comment>//y[i] = g[i][1];</span>
<a name="__line3283"></a>        }
<a name="__line3284"></a>        return new linear_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3285"></a>    }
<a name="__line3286"></a>    function function::interpolate_linear(const plottable &amp;g, const function &amp;x, const function &amp;y)
<a name="__line3287"></a>    {
<a name="__line3288"></a>        if(g.columns()&lt;2)
<a name="__line3289"></a>        {
<a name="__line3290"></a>            warning::print("The dgraph must have at least 2 colums","function::interpolate_linear(const dgraph &amp;, const function &amp;x, const function &amp;y)");
<a name="__line3291"></a>            return unset;
<a name="__line3292"></a>        }
<a name="__line3293"></a>        if(g.size()&lt;2)
<a name="__line3294"></a>        {
<a name="__line3295"></a>            warning::print("The dgraph must have at least 2 points","function::interpolate_linear(const dgraph &amp;, const function &amp;x const function &amp;y)");
<a name="__line3296"></a>            return unset;
<a name="__line3297"></a>        }
<a name="__line3298"></a>        bool multidim_x = (x.components()&gt;1);
<a name="__line3299"></a>        bool multidim_y = (y.components()&gt;1);
<a name="__line3300"></a>
<a name="__line3301"></a>        linear_interpolator_md&lt;double,double&gt;                *inter_md_1d = 0;
<a name="__line3302"></a>        linear_interpolator_md&lt;double,valarray&lt;double&gt; &gt;     *inter_md_md = 0;
<a name="__line3303"></a>        linear_interpolator_1d&lt;double,double&gt;                *inter_1d_1d = 0;
<a name="__line3304"></a>        linear_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;     *inter_1d_md = 0;
<a name="__line3305"></a>
<a name="__line3306"></a>        if(multidim_x)
<a name="__line3307"></a>        {
<a name="__line3308"></a>            if(multidim_y) inter_md_md = new linear_interpolator_md&lt;double,valarray&lt;double&gt; &gt;(x.components());
<a name="__line3309"></a>            else           inter_md_1d = new linear_interpolator_md&lt;double,double&gt;           (x.components());
<a name="__line3310"></a>        }
<a name="__line3311"></a>        else
<a name="__line3312"></a>        {
<a name="__line3313"></a>            if(multidim_y) inter_1d_md = new linear_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;;
<a name="__line3314"></a>            else           inter_1d_1d = new linear_interpolator_1d&lt;double,double&gt;;
<a name="__line3315"></a>        }
<a name="__line3316"></a>
<a name="__line3317"></a>        array xxx;
<a name="__line3318"></a>        xxx.resize(x.components());
<a name="__line3319"></a>        array yyy;
<a name="__line3320"></a>        yyy.resize(y.components());
<a name="__line3321"></a>
<a name="__line3322"></a>        <span class=comment>// For a multidimensional interpolator in x, one needs to loop over all gridpoints to set up the grid</span>
<a name="__line3323"></a>        <span class=comment>// of the interpolator</span>
<a name="__line3324"></a>        if(multidim_x)
<a name="__line3325"></a>        {
<a name="__line3326"></a>            vector&lt;vector&lt;double&gt; &gt; xvalues(x.components());
<a name="__line3327"></a>
<a name="__line3328"></a>            for(unsigned int i=0; i&lt;g.size(); ++i)
<a name="__line3329"></a>            {
<a name="__line3330"></a>                x.meval(*g.get(i),xxx);
<a name="__line3331"></a>                for(unsigned int i=0; i&lt;xxx.size(); ++i)
<a name="__line3332"></a>                {
<a name="__line3333"></a>                    if(find(xvalues[i].begin(),xvalues[i].end(),xxx[i].dbl()) == xvalues[i].end()) xvalues[i].push_back(xxx[i].dbl());
<a name="__line3334"></a>                }
<a name="__line3335"></a>            }
<a name="__line3336"></a>            for(unsigned int i=0; i&lt;xvalues.size(); ++i)
<a name="__line3337"></a>            {
<a name="__line3338"></a>                if(inter_md_1d) inter_md_1d-&gt;x(i+1,xvalues[i]);
<a name="__line3339"></a>                if(inter_md_md) inter_md_md-&gt;x(i+1,xvalues[i]);
<a name="__line3340"></a>            }
<a name="__line3341"></a>
<a name="__line3342"></a>        }
<a name="__line3343"></a>
<a name="__line3344"></a>        vector&lt;double&gt; XXX;
<a name="__line3345"></a>        XXX.resize(xxx.size());
<a name="__line3346"></a>        valarray&lt;double&gt; YYY;
<a name="__line3347"></a>        YYY.resize(yyy.size());
<a name="__line3348"></a>
<a name="__line3349"></a>        for(unsigned int ig=0; ig&lt;g.size(); ++ig)
<a name="__line3350"></a>        {
<a name="__line3351"></a>            x.meval(*g.get(ig),xxx);
<a name="__line3352"></a>            y.meval(*g.get(ig),yyy);
<a name="__line3353"></a>            if(multidim_y)
<a name="__line3354"></a>            {
<a name="__line3355"></a>                for(unsigned int i=0; i&lt;yyy.size(); ++i) YYY[i] = yyy[i].dbl();
<a name="__line3356"></a>            }
<a name="__line3357"></a>            if(multidim_x)
<a name="__line3358"></a>            {
<a name="__line3359"></a>                for(unsigned int i=0; i&lt;xxx.size(); ++i) XXX[i] = xxx[i].dbl();
<a name="__line3360"></a>                if(inter_md_1d) inter_md_1d-&gt;y(XXX,yyy[0].dbl());
<a name="__line3361"></a>                if(inter_md_md) inter_md_md-&gt;y(XXX,YYY);
<a name="__line3362"></a>            }
<a name="__line3363"></a>            else
<a name="__line3364"></a>            {
<a name="__line3365"></a>                if(inter_1d_1d) inter_1d_1d-&gt;add_point(xxx[0].dbl(),yyy[0].dbl());
<a name="__line3366"></a>                if(inter_1d_md) inter_1d_md-&gt;add_point(xxx[0].dbl(),YYY);
<a name="__line3367"></a>            }
<a name="__line3368"></a>        }
<a name="__line3369"></a>        if(inter_1d_1d) return inter_1d_1d;
<a name="__line3370"></a>        if(inter_1d_md) return inter_1d_md;
<a name="__line3371"></a>        if(inter_md_1d) return inter_md_1d;
<a name="__line3372"></a>        if(inter_md_md) return inter_md_md;
<a name="__line3373"></a>        warning::print("This should never happen","funtion::interpolate_linear(filename,x,y)");
<a name="__line3374"></a>        return unset;
<a name="__line3375"></a>    }
<a name="__line3376"></a>    function function::interpolate_linear(const array &amp;x, const array &amp;y)
<a name="__line3377"></a>    {
<a name="__line3378"></a>        return new linear_interpolator_1d&lt;double,double&gt;(x,y,::min(x.size(),y.size()));
<a name="__line3379"></a>    }
<a name="__line3380"></a>    function function::interpolate_linear(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y)
<a name="__line3381"></a>    {
<a name="__line3382"></a>        return new linear_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3383"></a>    }
<a name="__line3384"></a>    function function::interpolate_linear(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;geom::vec3&gt; &amp;y)
<a name="__line3385"></a>    {
<a name="__line3386"></a>        return new linear_interpolator_1d&lt;double,geom::vec3&gt;(x,y);
<a name="__line3387"></a>    }
<a name="__line3388"></a>    function function::interpolate_linear(const std::initializer_list&lt;double&gt; &amp;x, const std::initializer_list&lt;double&gt; &amp;y)
<a name="__line3389"></a>    {
<a name="__line3390"></a>        return new linear_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3391"></a>    }
<a name="__line3392"></a>    function function::interpolate_linear(const double x[], const double y[], int n)
<a name="__line3393"></a>    {
<a name="__line3394"></a>        return new linear_interpolator_1d&lt;double,double&gt;(x,y,n);
<a name="__line3395"></a>    }
<a name="__line3396"></a>
<a name="__line3397"></a>    function function::interpolate_spline(const dgraph &amp;g)
<a name="__line3398"></a>    {
<a name="__line3399"></a>        if(g.columns()&lt;2)
<a name="__line3400"></a>        {
<a name="__line3401"></a>            warning::print("The dgraph must have at least 2 colums","function::interpolate_linear(const dgraph &amp;)");
<a name="__line3402"></a>            return unset;
<a name="__line3403"></a>        }
<a name="__line3404"></a>        if(g.size()&lt;2)
<a name="__line3405"></a>        {
<a name="__line3406"></a>            warning::print("The dgraph must have at least 2 points","function::interpolate_linear(const dgraph &amp;)");
<a name="__line3407"></a>            return unset;
<a name="__line3408"></a>        }
<a name="__line3409"></a>        vector&lt;double&gt; x(g.size()),y(g.size());
<a name="__line3410"></a>        for(unsigned int i=0; i&lt;g.size(); ++i)
<a name="__line3411"></a>        {
<a name="__line3412"></a>            x[i] = g[i][0];
<a name="__line3413"></a>            y[i] = g[i][1];
<a name="__line3414"></a>        }
<a name="__line3415"></a>        return new spline_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3416"></a>    }
<a name="__line3417"></a>    function function::interpolate_spline(const array &amp;x, const array &amp;y)
<a name="__line3418"></a>    {
<a name="__line3419"></a>        return new spline_interpolator_1d&lt;double,double&gt;(x,y,::min(x.size(),y.size()));
<a name="__line3420"></a>    }
<a name="__line3421"></a>    function function::interpolate_spline(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y)
<a name="__line3422"></a>    {
<a name="__line3423"></a>        return new spline_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3424"></a>    }
<a name="__line3425"></a>    function function::interpolate_spline(const std::initializer_list&lt;double&gt; &amp;x, const std::initializer_list&lt;double&gt; &amp;y)
<a name="__line3426"></a>    {
<a name="__line3427"></a>        return new spline_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3428"></a>    }
<a name="__line3429"></a>    function function::interpolate_spline(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;geom::vec3&gt; &amp;y)
<a name="__line3430"></a>    {
<a name="__line3431"></a>        return new spline_interpolator_1d&lt;double,geom::vec3&gt;(x,y);
<a name="__line3432"></a>    }
<a name="__line3433"></a>    function function::interpolate_spline(const double x[], const double y[], int n)
<a name="__line3434"></a>    {
<a name="__line3435"></a>        return new spline_interpolator_1d&lt;double,double&gt;(x,y,n);
<a name="__line3436"></a>    }
<a name="__line3437"></a>
<a name="__line3438"></a>    function function::interpolate_sppchip(const dgraph &amp;g)
<a name="__line3439"></a>    {
<a name="__line3440"></a>        if(g.columns()&lt;2)
<a name="__line3441"></a>        {
<a name="__line3442"></a>            warning::print("The dgraph must have at least 2 colums","function::interpolate_linear(const dgraph &amp;)");
<a name="__line3443"></a>            return unset;
<a name="__line3444"></a>        }
<a name="__line3445"></a>        if(g.size()&lt;2)
<a name="__line3446"></a>        {
<a name="__line3447"></a>            warning::print("The dgraph must have at least 2 points","function::interpolate_linear(const dgraph &amp;)");
<a name="__line3448"></a>            return unset;
<a name="__line3449"></a>        }
<a name="__line3450"></a>        vector&lt;double&gt; x(g.size()),y(g.size());
<a name="__line3451"></a>        for(unsigned int i=0; i&lt;g.size(); ++i)
<a name="__line3452"></a>        {
<a name="__line3453"></a>            x[i] = g[i][0];
<a name="__line3454"></a>            y[i] = g[i][1];
<a name="__line3455"></a>        }
<a name="__line3456"></a>        return new sppchip_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3457"></a>    }
<a name="__line3458"></a>    function function::interpolate_sppchip(const array &amp;x, const array &amp;y)
<a name="__line3459"></a>    {
<a name="__line3460"></a>        return new sppchip_interpolator_1d&lt;double,double&gt;(x,y,::min(x.size(),y.size()));
<a name="__line3461"></a>    }
<a name="__line3462"></a>    function function::interpolate_sppchip(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y)
<a name="__line3463"></a>    {
<a name="__line3464"></a>        return new sppchip_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3465"></a>    }
<a name="__line3466"></a>    function function::interpolate_sppchip(const std::initializer_list&lt;double&gt; &amp;x, const std::initializer_list&lt;double&gt; &amp;y)
<a name="__line3467"></a>    {
<a name="__line3468"></a>        return new sppchip_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3469"></a>    }
<a name="__line3470"></a>    function function::interpolate_sppchip(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;geom::vec3&gt; &amp;y)
<a name="__line3471"></a>    {
<a name="__line3472"></a>        return new sppchip_interpolator_1d&lt;double,geom::vec3&gt;(x,y);
<a name="__line3473"></a>    }
<a name="__line3474"></a>    function function::interpolate_sppchip(const double x[], const double y[], int n)
<a name="__line3475"></a>    {
<a name="__line3476"></a>        return new sppchip_interpolator_1d&lt;double,double&gt;(x,y,n);
<a name="__line3477"></a>    }
<a name="__line3478"></a>
<a name="__line3479"></a>
<a name="__line3480"></a>
<a name="__line3481"></a>#ifdef HAVE_GTS_H
<a name="__line3482"></a>
<a name="__line3483"></a>    function function::interpolate_delaunay(const var &amp;filename)
<a name="__line3484"></a>    {
<a name="__line3485"></a>        return interpolate_delaunay(filename,function(_1,_2),_3);
<a name="__line3486"></a>    }
<a name="__line3487"></a>
<a name="__line3488"></a>    function function::interpolate_delaunay(const var &amp;filename, const function &amp;x, const function &amp;y)
<a name="__line3489"></a>    {
<a name="__line3490"></a>        if(x.components() != 2)
<a name="__line3491"></a>        {
<a name="__line3492"></a>            warning::print("Delaunay-interpolation needs 2 x-values","function::interpolate_delaunay(filename,const function &amp;x, const function &amp;y)");
<a name="__line3493"></a>            return unset;
<a name="__line3494"></a>        }
<a name="__line3495"></a>        if(y.components() != 1)
<a name="__line3496"></a>        {
<a name="__line3497"></a>            warning::print("Delaunay-interpolation needs 1 y-value","function::interpolate_delaunay(filename,const function &amp;x, const function &amp;y)");
<a name="__line3498"></a>            return unset;
<a name="__line3499"></a>        }
<a name="__line3500"></a>
<a name="__line3501"></a>        istream *file = openin(filename);
<a name="__line3502"></a>        if(!file) return unset;
<a name="__line3503"></a>
<a name="__line3504"></a>        delaunay_interpolator *inter = new delaunay_interpolator;
<a name="__line3505"></a>
<a name="__line3506"></a>        array line;
<a name="__line3507"></a>        array xx;
<a name="__line3508"></a>        xx.resize(x.components());
<a name="__line3509"></a>        array yy;
<a name="__line3510"></a>        yy.resize(y.components());
<a name="__line3511"></a>        while(getline(*file,line))
<a name="__line3512"></a>        {
<a name="__line3513"></a>            if(line.empty()) continue;
<a name="__line3514"></a>            if(line[0][0] == '#') continue;
<a name="__line3515"></a>
<a name="__line3516"></a>            x.meval(line,xx);
<a name="__line3517"></a>            y.meval(line,yy);
<a name="__line3518"></a>            
<a name="__line3519"></a>            inter-&gt;add_point(xx[0].dbl(), xx[1].dbl(), yy[0].dbl());
<a name="__line3520"></a>        }
<a name="__line3521"></a>
<a name="__line3522"></a>        return *inter;
<a name="__line3523"></a>    }
<a name="__line3524"></a>
<a name="__line3525"></a>#endif
<a name="__line3526"></a>
<a name="__line3527"></a>
<a name="__line3528"></a>    <span class=comment>/*
<a name="__line3529"></a>    function function::linear(const var &amp;filename,
<a name="__line3530"></a>			      const function &amp;f1,
<a name="__line3531"></a>			      const function &amp;f2,
<a name="__line3532"></a>			      const function &amp;f3,
<a name="__line3533"></a>			      const function &amp;f4)
<a name="__line3534"></a>			      
<a name="__line3535"></a>    {
<a name="__line3536"></a>        warning::print("function::linear is deprecated, use function::interpolate_linear(...) instead, which can also do multidimensional interpolation");
<a name="__line3537"></a>	array line, result;
<a name="__line3538"></a>
<a name="__line3539"></a>	function filter = unset;
<a name="__line3540"></a>	if(f1.initialized()) filter.append(f1);
<a name="__line3541"></a>	if(f2.initialized()) filter.append(f2);
<a name="__line3542"></a>	if(f3.initialized()) filter.append(f3);
<a name="__line3543"></a>	if(f4.initialized()) filter.append(f4);
<a name="__line3544"></a>	unsigned int N = 0;
<a name="__line3545"></a>	if(filter.initialized())
<a name="__line3546"></a>	{
<a name="__line3547"></a>	    N = filter.components();
<a name="__line3548"></a>	    result.resize(N);
<a name="__line3549"></a>	}
<a name="__line3550"></a>
<a name="__line3551"></a>	polynomial_interpolator_1d&lt;double,double&gt;            *interp_double   = 0;
<a name="__line3552"></a>	polynomial_interpolator_1d&lt;double,valarray&lt;double&gt; &gt; *interp_valarray = 0;
<a name="__line3553"></a>
<a name="__line3554"></a>	istream *file = openin(filename);
<a name="__line3555"></a>
<a name="__line3556"></a>	while(getline(*file,line))
<a name="__line3557"></a>	{
<a name="__line3558"></a>	    if(line.empty()) continue;
<a name="__line3559"></a>	    if(line[0].str()[0] == '#') continue;
<a name="__line3560"></a>	    if(filter.initialized()) filter.meval(line,result);
<a name="__line3561"></a>	    else
<a name="__line3562"></a>	    {
<a name="__line3563"></a>		if(N == 0) N = line.size();
<a name="__line3564"></a>		result = line;
<a name="__line3565"></a>	    }
<a name="__line3566"></a>
<a name="__line3567"></a>	    if(N&gt;2) // valarray is needed
<a name="__line3568"></a>	    {
<a name="__line3569"></a>		if(interp_valarray == 0) interp_valarray = new polynomial_interpolator_1d&lt;double,valarray&lt;double&gt; &gt;;
<a name="__line3570"></a>		valarray&lt;double&gt; r(N-1);
<a name="__line3571"></a>		for(unsigned int i=1; i&lt;result.size(); ++i) r[i-1] = result[i].dbl();
<a name="__line3572"></a>		interp_valarray-&gt;add_point(result[0].dbl(), r);
<a name="__line3573"></a>	    }
<a name="__line3574"></a>	    else
<a name="__line3575"></a>	    {
<a name="__line3576"></a>		if(interp_double   == 0) interp_double   = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3577"></a>		interp_double-&gt;add_point(result[0].dbl(), result[1].dbl());
<a name="__line3578"></a>	    }
<a name="__line3579"></a>	}
<a name="__line3580"></a>
<a name="__line3581"></a>	if(interp_double &amp;&amp; interp_double-&gt;linear())
<a name="__line3582"></a>	{
<a name="__line3583"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp_double);
<a name="__line3584"></a>	    return c;
<a name="__line3585"></a>	}
<a name="__line3586"></a>	if(interp_valarray &amp;&amp; interp_valarray-&gt;linear())
<a name="__line3587"></a>	{
<a name="__line3588"></a>	    function_core::interpolated_func&lt;valarray&lt;double&gt; &gt; *c = new function_core::interpolated_func&lt;valarray&lt;double&gt; &gt;(interp_valarray);
<a name="__line3589"></a>	    return c;
<a name="__line3590"></a>	}
<a name="__line3591"></a>	delete interp_double;
<a name="__line3592"></a>	delete interp_valarray;
<a name="__line3593"></a>	return 0.0;
<a name="__line3594"></a>    }
<a name="__line3595"></a>
<a name="__line3596"></a>    function function::linear(const array &amp;x, const array &amp;y)
<a name="__line3597"></a>    {
<a name="__line3598"></a>	unsigned int n = ::min(x.size(), y.size());
<a name="__line3599"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3600"></a>	for(unsigned int i=0; i&lt;n; ++i) interp-&gt;add_point(x[i].dbl(), y[i].dbl());
<a name="__line3601"></a>	if(interp-&gt;linear())
<a name="__line3602"></a>	{
<a name="__line3603"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3604"></a>	    return c;
<a name="__line3605"></a>	}
<a name="__line3606"></a>	delete interp;
<a name="__line3607"></a>	return 0.0;
<a name="__line3608"></a>    }
<a name="__line3609"></a>
<a name="__line3610"></a>    function function::linear(const vector&lt;double&gt; &amp;x, const vector&lt;double&gt; &amp;y)
<a name="__line3611"></a>    {
<a name="__line3612"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3613"></a>	if(interp-&gt;linear())
<a name="__line3614"></a>	{
<a name="__line3615"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3616"></a>	    return c;
<a name="__line3617"></a>	}
<a name="__line3618"></a>	delete interp;
<a name="__line3619"></a>	return 0.0;
<a name="__line3620"></a>    }
<a name="__line3621"></a>
<a name="__line3622"></a>    function function::linear(const double x[], const double y[], int n)
<a name="__line3623"></a>    {
<a name="__line3624"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3625"></a>	for(int i=0; i&lt;n; ++i) interp-&gt;add_point(x[i],y[i]);
<a name="__line3626"></a>	if(interp-&gt;linear())
<a name="__line3627"></a>	{
<a name="__line3628"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3629"></a>	    return c;
<a name="__line3630"></a>	}
<a name="__line3631"></a>	delete interp;
<a name="__line3632"></a>	return 0.0;
<a name="__line3633"></a>    }
<a name="__line3634"></a>
<a name="__line3635"></a>    function function::spline(const var &amp;filename,
<a name="__line3636"></a>			      const function &amp;f1,
<a name="__line3637"></a>			      const function &amp;f2,
<a name="__line3638"></a>			      const function &amp;f3,
<a name="__line3639"></a>			      const function &amp;f4)
<a name="__line3640"></a>			      
<a name="__line3641"></a>    {
<a name="__line3642"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3643"></a>
<a name="__line3644"></a>	istream *file = openin(filename);
<a name="__line3645"></a>
<a name="__line3646"></a>	function filter = unset;
<a name="__line3647"></a>	if(f1.initialized()) filter.append(f1);
<a name="__line3648"></a>	if(f2.initialized()) filter.append(f2);
<a name="__line3649"></a>	if(f3.initialized()) filter.append(f3);
<a name="__line3650"></a>	if(f4.initialized()) filter.append(f4);
<a name="__line3651"></a>
<a name="__line3652"></a>	array line, result;
<a name="__line3653"></a>
<a name="__line3654"></a>	unsigned int N = 0;
<a name="__line3655"></a>	if(filter.initialized())
<a name="__line3656"></a>	{
<a name="__line3657"></a>	    N = filter.components();
<a name="__line3658"></a>	    result.resize(N);
<a name="__line3659"></a>	}
<a name="__line3660"></a>	while(getline(*file,line))
<a name="__line3661"></a>	{
<a name="__line3662"></a>	    if(line.empty()) continue;
<a name="__line3663"></a>	    if(line[0].str()[0] == '#') continue;
<a name="__line3664"></a>	    if(filter.initialized()) filter.meval(line,result);
<a name="__line3665"></a>	    else
<a name="__line3666"></a>	    {
<a name="__line3667"></a>		if(N == 0) N = line.size();
<a name="__line3668"></a>		result = line;
<a name="__line3669"></a>	    }
<a name="__line3670"></a>
<a name="__line3671"></a>	    if(result.size()&lt;2) warning::print("Less than 2 values for spline interpolation","function::spline(filename,f1,f2,...)");
<a name="__line3672"></a>
<a name="__line3673"></a>	    interp-&gt;add_point((result.size()&gt;0?result[0].dbl():0.0), (result.size()&gt;1?result[1].dbl():0.0));
<a name="__line3674"></a>	}
<a name="__line3675"></a>
<a name="__line3676"></a>	if(N&gt;2)
<a name="__line3677"></a>	{
<a name="__line3678"></a>	    warning::print("Spline interpolation currently only works for (x,y) pairs (i.e. no more y values, valarray...). Request from the author!");
<a name="__line3679"></a>	}
<a name="__line3680"></a>
<a name="__line3681"></a>	if(interp-&gt;spline())
<a name="__line3682"></a>	{
<a name="__line3683"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3684"></a>	    return c;
<a name="__line3685"></a>	}
<a name="__line3686"></a>	delete interp;
<a name="__line3687"></a>	return 0.0;
<a name="__line3688"></a>    }
<a name="__line3689"></a>
<a name="__line3690"></a>    function function::spline(const array &amp;x, const array &amp;y)
<a name="__line3691"></a>    {
<a name="__line3692"></a>	unsigned int n = ::min(x.size(), y.size());
<a name="__line3693"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3694"></a>	for(unsigned int i=0; i&lt;n; ++i) interp-&gt;add_point(x[i].dbl(), y[i].dbl());
<a name="__line3695"></a>	if(interp-&gt;spline())
<a name="__line3696"></a>	{
<a name="__line3697"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3698"></a>	    return c;
<a name="__line3699"></a>	}
<a name="__line3700"></a>	delete interp;
<a name="__line3701"></a>	return 0.0;
<a name="__line3702"></a>    }
<a name="__line3703"></a>
<a name="__line3704"></a>    function function::spline(const vector&lt;double&gt; &amp;x, const vector&lt;double&gt; &amp;y)
<a name="__line3705"></a>    {
<a name="__line3706"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3707"></a>	if(interp-&gt;spline())
<a name="__line3708"></a>	{
<a name="__line3709"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3710"></a>	    return c;
<a name="__line3711"></a>	}
<a name="__line3712"></a>	delete interp;
<a name="__line3713"></a>	return 0.0;
<a name="__line3714"></a>    }
<a name="__line3715"></a>
<a name="__line3716"></a>    function function::spline(const double x[], const double y[], int n)
<a name="__line3717"></a>    {
<a name="__line3718"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3719"></a>	for(int i=0; i&lt;n; ++i) interp-&gt;add_point(x[i],y[i]);
<a name="__line3720"></a>	if(interp-&gt;spline())
<a name="__line3721"></a>	{
<a name="__line3722"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3723"></a>	    return c;
<a name="__line3724"></a>	}
<a name="__line3725"></a>	delete interp;
<a name="__line3726"></a>	return 0.0;
<a name="__line3727"></a>    }
<a name="__line3728"></a>
<a name="__line3729"></a>    // --------------  shape-preserving piecewise cubic hermite interpolating polynomial ----
<a name="__line3730"></a>    function function::sppchip(const var &amp;filename,
<a name="__line3731"></a>			      const function &amp;f1,
<a name="__line3732"></a>			      const function &amp;f2,
<a name="__line3733"></a>			      const function &amp;f3,
<a name="__line3734"></a>			      const function &amp;f4)
<a name="__line3735"></a>			      
<a name="__line3736"></a>    {
<a name="__line3737"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3738"></a>
<a name="__line3739"></a>	istream *file = openin(filename);
<a name="__line3740"></a>
<a name="__line3741"></a>	function filter = unset;
<a name="__line3742"></a>	if(f1.initialized()) filter.append(f1);
<a name="__line3743"></a>	if(f2.initialized()) filter.append(f2);
<a name="__line3744"></a>	if(f3.initialized()) filter.append(f3);
<a name="__line3745"></a>	if(f4.initialized()) filter.append(f4);
<a name="__line3746"></a>
<a name="__line3747"></a>	array line, result;
<a name="__line3748"></a>
<a name="__line3749"></a>	unsigned int N = 0;
<a name="__line3750"></a>	if(filter.initialized())
<a name="__line3751"></a>	{
<a name="__line3752"></a>	    N = filter.components();
<a name="__line3753"></a>	    result.resize(N);
<a name="__line3754"></a>	}
<a name="__line3755"></a>	while(getline(*file,line))
<a name="__line3756"></a>	{
<a name="__line3757"></a>	    if(line.empty()) continue;
<a name="__line3758"></a>	    if(line[0].str()[0] == '#') continue;
<a name="__line3759"></a>	    if(filter.initialized()) filter.meval(line,result);
<a name="__line3760"></a>	    else
<a name="__line3761"></a>	    {
<a name="__line3762"></a>		if(N == 0) N = line.size();
<a name="__line3763"></a>		result = line;
<a name="__line3764"></a>	    }
<a name="__line3765"></a>
<a name="__line3766"></a>	    interp-&gt;add_point(result[0].dbl(), result[1].dbl());
<a name="__line3767"></a>	}
<a name="__line3768"></a>
<a name="__line3769"></a>	if(interp-&gt;sppchip())
<a name="__line3770"></a>	{
<a name="__line3771"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3772"></a>	    return c;
<a name="__line3773"></a>	}
<a name="__line3774"></a>	delete interp;
<a name="__line3775"></a>	return 0.0;
<a name="__line3776"></a>    }
<a name="__line3777"></a>
<a name="__line3778"></a>    function function::sppchip(const array &amp;x, const array &amp;y)
<a name="__line3779"></a>    {
<a name="__line3780"></a>	unsigned int n = ::min(x.size(), y.size());
<a name="__line3781"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3782"></a>	for(unsigned int i=0; i&lt;n; ++i) interp-&gt;add_point(x[i].dbl(), y[i].dbl());
<a name="__line3783"></a>	if(interp-&gt;sppchip())
<a name="__line3784"></a>	{
<a name="__line3785"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3786"></a>	    return c;
<a name="__line3787"></a>	}
<a name="__line3788"></a>	delete interp;
<a name="__line3789"></a>	return 0.0;
<a name="__line3790"></a>    }
<a name="__line3791"></a>
<a name="__line3792"></a>    function function::sppchip(const vector&lt;double&gt; &amp;x, const vector&lt;double&gt; &amp;y)
<a name="__line3793"></a>    {
<a name="__line3794"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;(x,y);
<a name="__line3795"></a>	if(interp-&gt;sppchip())
<a name="__line3796"></a>	{
<a name="__line3797"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3798"></a>	    return c;
<a name="__line3799"></a>	}
<a name="__line3800"></a>	delete interp;
<a name="__line3801"></a>	return 0.0;
<a name="__line3802"></a>    }
<a name="__line3803"></a>
<a name="__line3804"></a>    function function::sppchip(const double x[], const double y[], int n)
<a name="__line3805"></a>    {
<a name="__line3806"></a>	polynomial_interpolator_1d&lt;double,double&gt; *interp = new polynomial_interpolator_1d&lt;double,double&gt;;
<a name="__line3807"></a>	for(int i=0; i&lt;n; ++i) interp-&gt;add_point(x[i],y[i]);
<a name="__line3808"></a>	if(interp-&gt;sppchip())
<a name="__line3809"></a>	{
<a name="__line3810"></a>	    function_core::interpolated_func&lt;double&gt; *c = new function_core::interpolated_func&lt;double&gt;(interp);
<a name="__line3811"></a>	    return c;
<a name="__line3812"></a>	}
<a name="__line3813"></a>	delete interp;
<a name="__line3814"></a>	return 0.0;
<a name="__line3815"></a>    }
<a name="__line3816"></a>    */</span>
<a name="__line3817"></a>
<a name="__line3818"></a>
<a name="__line3819"></a>
<a name="__line3820"></a>
<a name="__line3821"></a>#ifdef __MAKECINT__
<a name="__line3822"></a>    function cfunc(void *p)             {  return function_core::cfunc(p); }
<a name="__line3823"></a>#endif
<a name="__line3824"></a>    function cfunc(var (*p)(var))       {  return function_core::cfunc(p); }
<a name="__line3825"></a>    function cfunc(var (*p)(var,var))   {  return function_core::cfunc(p); }
<a name="__line3826"></a>    function cfunc(var (*p)(var,var,var)) {  return function_core::cfunc(p); }
<a name="__line3827"></a>    function cfunc(var (*p)(var,var,var,var)) {  return function_core::cfunc(p); }
<a name="__line3828"></a>    function cfunc(double (*p)(double)) {  return function_core::cfunc(p); }
<a name="__line3829"></a>    function cfunc(double (*p)(double,double)) {  return function_core::cfunc(p); }
<a name="__line3830"></a>    function cfunc(double (*p)(double,double,double)) {  return function_core::cfunc(p); }
<a name="__line3831"></a>    function cfunc(double (*p)(double,double,double,double)) {  return function_core::cfunc(p); }
<a name="__line3832"></a>    function cfunc(complex&lt;double&gt; (*p)(double)) { return function_core::cfunc(p); }
<a name="__line3833"></a>    function cfunc(var (*p)(const std::vector&lt;blop::var&gt; &amp;args,
<a name="__line3834"></a>			    const std::vector&lt;blop::var&gt; &amp;pars),
<a name="__line3835"></a>		   int nargs, int npars) { return function_core::cfunc(p,nargs,npars); }
<a name="__line3836"></a>    function cfunc(void (*p)(double*,double*,double*), int nargs, int npars, int nout)
<a name="__line3837"></a>    {
<a name="__line3838"></a>        return function_core::cfunc(p,nargs, npars, nout);
<a name="__line3839"></a>    }
<a name="__line3840"></a>
<a name="__line3841"></a><span class=comment>/*
<a name="__line3842"></a>    function cppfunc(void (*p)(double*,double*,double*), int nargs, int npars, int nout)
<a name="__line3843"></a>    {
<a name="__line3844"></a>        return function_core::cppfunc&lt;void(double*,double*,double*)&gt;(p,nargs, npars, nout);
<a name="__line3845"></a>    }
<a name="__line3846"></a>*/</span>
<a name="__line3847"></a>
<a name="__line3848"></a>    function     cppfunc   (const std::function&lt;void(double*,double*,double*)&gt; &amp;func, int nargs, int npars, int nout)
<a name="__line3849"></a>    {
<a name="__line3850"></a>        return function_core::cppfunc&lt;void(double*,double*,double*)&gt;(func, nargs, npars, nout);
<a name="__line3851"></a>    }
<a name="__line3852"></a>
<a name="__line3853"></a>
<a name="__line3854"></a>    function::global_initializer::global_initializer()
<a name="__line3855"></a>    {
<a name="__line3856"></a>	static int count = 0;
<a name="__line3857"></a>	if(count++ == 0)
<a name="__line3858"></a>	{
<a name="__line3859"></a>	    new(&amp;_1) function(new function_core::arg(1));
<a name="__line3860"></a>	    new(&amp;_2) function(new function_core::arg(2));
<a name="__line3861"></a>	    new(&amp;_3) function(new function_core::arg(3));
<a name="__line3862"></a>	    new(&amp;_4) function(new function_core::arg(4));
<a name="__line3863"></a>	    new(&amp;_5) function(new function_core::arg(5));
<a name="__line3864"></a>	    new(&amp;_6) function(new function_core::arg(6));
<a name="__line3865"></a>	    new(&amp;_7) function(new function_core::arg(7));
<a name="__line3866"></a>	    new(&amp;_8) function(new function_core::arg(8));
<a name="__line3867"></a>	    new(&amp;_9) function(new function_core::arg(9));
<a name="__line3868"></a>	    new(&amp;_10) function(new function_core::arg(10));
<a name="__line3869"></a>	    new(&amp;_11) function(new function_core::arg(11));
<a name="__line3870"></a>	    new(&amp;_12) function(new function_core::arg(12));
<a name="__line3871"></a>	    new(&amp;_13) function(new function_core::arg(13));
<a name="__line3872"></a>	    new(&amp;_14) function(new function_core::arg(14));
<a name="__line3873"></a>	    new(&amp;_15) function(new function_core::arg(15));
<a name="__line3874"></a>	    new(&amp;_16) function(new function_core::arg(16));
<a name="__line3875"></a>	    new(&amp;_17) function(new function_core::arg(17));
<a name="__line3876"></a>	    new(&amp;_18) function(new function_core::arg(18));
<a name="__line3877"></a>	    new(&amp;_19) function(new function_core::arg(19));
<a name="__line3878"></a>	    new(&amp;_20) function(new function_core::arg(20));
<a name="__line3879"></a>	    new(&amp;_N)  function(new function_core::actual_nargs);
<a name="__line3880"></a>	    new(&amp;_0)  function(new function_core::named_param("linenumber"));
<a name="__line3881"></a>	    new(&amp;_b)  function(new function_core::named_param("blocknumber"));
<a name="__line3882"></a>	    new(&amp;_B)  function(new function_core::named_param("Blocknumber"));
<a name="__line3883"></a>	    new(&amp;_g)  function(new function_core::named_param("groupingvalue"));
<a name="__line3884"></a>	}
<a name="__line3885"></a>    }
<a name="__line3886"></a>
<a name="__line3887"></a>    double tan(double a) { return std::tan(a); }
<a name="__line3888"></a>
<a name="__line3889"></a>    function function::find_root(const function &amp;f, const function &amp;x1, const function &amp;x2, const function &amp;epsilon)
<a name="__line3890"></a>    {
<a name="__line3891"></a>        return function_core::find_root(f.base_, x1.base_, x2.base_, epsilon.base_);
<a name="__line3892"></a>    }
<a name="__line3893"></a>
<a name="__line3894"></a>    double find_root(const function &amp;f, double x1, double x2, double epsilon)
<a name="__line3895"></a>    {
<a name="__line3896"></a>        if(x2&lt;x1) swap(x1,x2);
<a name="__line3897"></a>        double f1 = f(x1).dbl();
<a name="__line3898"></a>        double f2 = f(x2).dbl();
<a name="__line3899"></a>        if(epsilon&lt;0) epsilon = (x2-x1)/1000000;
<a name="__line3900"></a>        if(f1*f2 &gt;= 0)
<a name="__line3901"></a>        {
<a name="__line3902"></a>            warning::print(var("f(") &amp; x1 &amp; ")=" &amp; f(x1) &amp; " and f(" &amp; x2 &amp; ")=" &amp; f(x2) &amp; " should have opposite signs",
<a name="__line3903"></a>                               "find_root(const function &amp;, double x1, double x2)");
<a name="__line3904"></a>            return x1;
<a name="__line3905"></a>        }
<a name="__line3906"></a>
<a name="__line3907"></a>        while(::fabs(x2-x1)&gt;epsilon)
<a name="__line3908"></a>        {
<a name="__line3909"></a>            const double xx = 0.5*(x1+x2);
<a name="__line3910"></a>            const double ff = f(xx).dbl();
<a name="__line3911"></a>            if(ff == 0.0) return xx;
<a name="__line3912"></a>            if(f1*ff&lt;0)
<a name="__line3913"></a>            {
<a name="__line3914"></a>                x2 = xx;
<a name="__line3915"></a>                f2 = ff;
<a name="__line3916"></a>            }
<a name="__line3917"></a>            else if(f2*ff&lt;0)
<a name="__line3918"></a>            {
<a name="__line3919"></a>                x1 = xx;
<a name="__line3920"></a>                f1 = ff;
<a name="__line3921"></a>            }
<a name="__line3922"></a>            else
<a name="__line3923"></a>            {
<a name="__line3924"></a>                warning::print("This should not happen","find_root(const function &amp;, double x1, double x2)");
<a name="__line3925"></a>                return 0.5*(x1+x2);
<a name="__line3926"></a>            }
<a name="__line3927"></a>        }
<a name="__line3928"></a>        return 0.5*(x1+x2);
<a name="__line3929"></a>    }
<a name="__line3930"></a>
<a name="__line3931"></a>    double find_root(const std::vector&lt;double&gt; &amp;X, const std::vector&lt;double&gt; &amp;Y, const function &amp;F, double epsilon)
<a name="__line3932"></a>    {
<a name="__line3933"></a>        if(X.size()&lt;=1) return unset;
<a name="__line3934"></a>        function ff = function::interpolate_linear(X,Y)-F;
<a name="__line3935"></a>        return blop::find_root(ff, X.front(), X.back(), epsilon);
<a name="__line3936"></a>    }
<a name="__line3937"></a>
<a name="__line3938"></a>    double find_root(const dgraph &amp;g, double yvalue)
<a name="__line3939"></a>    {
<a name="__line3940"></a>        const unsigned int N = g.size();
<a name="__line3941"></a>        for(unsigned int i=1; i&lt;N; ++i)
<a name="__line3942"></a>        {
<a name="__line3943"></a>            const double x1 = g[i-1][0];
<a name="__line3944"></a>            const double y1 = g[i-1][1];
<a name="__line3945"></a>            const double x2 = g[i][0];
<a name="__line3946"></a>            const double y2 = g[i][1];
<a name="__line3947"></a>            if((y2-yvalue)*(y1-yvalue)&lt;=0.0)
<a name="__line3948"></a>            {
<a name="__line3949"></a>                const double a = (y2-y1)/(x2-x1);
<a name="__line3950"></a>                const double b = (x2*y1-x1*y2)/(x2-x1);
<a name="__line3951"></a>                return (yvalue-b)/a;
<a name="__line3952"></a>            }
<a name="__line3953"></a>        }
<a name="__line3954"></a>        return unset;
<a name="__line3955"></a>    }
<a name="__line3956"></a>
<a name="__line3957"></a>    unsigned int find_roots(const dgraph &amp;g, std::vector&lt;double&gt; &amp;roots, double yvalue)
<a name="__line3958"></a>    {
<a name="__line3959"></a>        roots.clear();
<a name="__line3960"></a>        const unsigned int N = g.size();
<a name="__line3961"></a>        for(unsigned int i=1; i&lt;N; ++i)
<a name="__line3962"></a>        {
<a name="__line3963"></a>            const double x1 = g[i-1][0];
<a name="__line3964"></a>            const double y1 = g[i-1][1];
<a name="__line3965"></a>            const double x2 = g[i][0];
<a name="__line3966"></a>            const double y2 = g[i][1];
<a name="__line3967"></a>            if((y2-yvalue)*(y1-yvalue)&lt;=0.0)
<a name="__line3968"></a>            {
<a name="__line3969"></a>                const double a = (y2-y1)/(x2-x1);
<a name="__line3970"></a>                const double b = (x2*y1-x1*y2)/(x2-x1);
<a name="__line3971"></a>                roots.push_back((yvalue-b)/a);
<a name="__line3972"></a>            }
<a name="__line3973"></a>        }
<a name="__line3974"></a>        return roots.size();
<a name="__line3975"></a>    }
<a name="__line3976"></a>
<a name="__line3977"></a>
<a name="__line3978"></a>    double find_root(const std::vector&lt;double&gt; &amp;x, const std::vector&lt;double&gt; &amp;y, double yvalue)
<a name="__line3979"></a>    {
<a name="__line3980"></a>        const unsigned int N = ::min(x.size(),y.size());
<a name="__line3981"></a>        for(unsigned int i=1; i&lt;N; ++i)
<a name="__line3982"></a>        {
<a name="__line3983"></a>            const double x1 = x[i-1];
<a name="__line3984"></a>            const double y1 = y[i-1];
<a name="__line3985"></a>            const double x2 = x[i];
<a name="__line3986"></a>            const double y2 = y[i];
<a name="__line3987"></a>            if((y2-yvalue)*(y1-yvalue)&lt;=0.0)
<a name="__line3988"></a>            {
<a name="__line3989"></a>                const double a = (y2-y1)/(x2-x1);
<a name="__line3990"></a>                const double b = (x2*y1-x1*y2)/(x2-x1);
<a name="__line3991"></a>                return (yvalue-b)/a;
<a name="__line3992"></a>            }
<a name="__line3993"></a>        }
<a name="__line3994"></a>        return unset;
<a name="__line3995"></a>    }
<a name="__line3996"></a>
<a name="__line3997"></a>    blop::function implicit_solve(const function &amp;f, double x1, double x2, double y1, double y2,int n1, int n2)
<a name="__line3998"></a>    {
<a name="__line3999"></a>        vector&lt;double&gt; x,y;
<a name="__line4000"></a>        isoline(f,0.0,x,y,x1,x2,y1,y2,n1,n2);
<a name="__line4001"></a>        parallel_sort(x,y);
<a name="__line4002"></a>        for(unsigned int i=1; i&lt;x.size();)
<a name="__line4003"></a>        {
<a name="__line4004"></a>            if(std::abs(x[i]-x[i-1])&lt;(x2-x1)/n1/10)
<a name="__line4005"></a>            {
<a name="__line4006"></a>                x.erase(x.begin()+i);
<a name="__line4007"></a>                y.erase(y.begin()+i);
<a name="__line4008"></a>            }
<a name="__line4009"></a>
<a name="__line4010"></a>            else ++i;
<a name="__line4011"></a>        }
<a name="__line4012"></a>        if(x.size()&lt;=1) return unset;
<a name="__line4013"></a>        return function::interpolate_linear(x,y);
<a name="__line4014"></a>    }
<a name="__line4015"></a>
<a name="__line4016"></a>    blop::function implicit_solve(const dgraph &amp;g, double zcut)
<a name="__line4017"></a>    {
<a name="__line4018"></a>        std::vector&lt;double&gt; x,y;
<a name="__line4019"></a>        isoline(g,zcut,x,y);
<a name="__line4020"></a>        parallel_sort(x,y);
<a name="__line4021"></a>        if(x.size() &lt;= 1) return unset;
<a name="__line4022"></a>        const double D = (x.back() - x.front())/1000;
<a name="__line4023"></a>        for(unsigned int i=1; i&lt;x.size();)
<a name="__line4024"></a>        {
<a name="__line4025"></a>            if(std::abs(x[i]-x[i-1])&lt;D)
<a name="__line4026"></a>            {
<a name="__line4027"></a>                x.erase(x.begin()+i);
<a name="__line4028"></a>                y.erase(y.begin()+i);
<a name="__line4029"></a>            }
<a name="__line4030"></a>
<a name="__line4031"></a>            else ++i;
<a name="__line4032"></a>        }
<a name="__line4033"></a>        if(x.size()&lt;=1) return unset;
<a name="__line4034"></a>        return function::interpolate_linear(x,y);
<a name="__line4035"></a>    }
<a name="__line4036"></a>
<a name="__line4037"></a>    blop::function replace(const blop::function &amp;from, const blop::function &amp;to, const blop::function &amp;in)
<a name="__line4038"></a>    {
<a name="__line4039"></a>        return new blop::function_core::replace(from.base_,to.base_,in.base_);
<a name="__line4040"></a>    }
<a name="__line4041"></a>
<a name="__line4042"></a>    blop::function substr(const blop::function &amp;s, const blop::function &amp;from, const blop::function &amp;to)
<a name="__line4043"></a>    {
<a name="__line4044"></a>        return new blop::function_core::substr(s.base_,from.base_,to.base_);
<a name="__line4045"></a>    }
<a name="__line4046"></a>
<a name="__line4047"></a>    var polylegend(const function &amp;f, int n, const var &amp;independent_variable)
<a name="__line4048"></a>    {
<a name="__line4049"></a>        var result = f.param(1);
<a name="__line4050"></a>        for(int i=1; i&lt;=n; ++i)
<a name="__line4051"></a>        {
<a name="__line4052"></a>            if(f.param(i+1)&gt;=0) result &amp;= "+";
<a name="__line4053"></a>            result &amp;= f.param(i+1) &amp; (i&gt;1?var("$\\cdot ") &amp; independent_variable &amp; "^{" &amp; i &amp; "}$":var("$\\cdot ") &amp; independent_variable &amp; "$");
<a name="__line4054"></a>        }
<a name="__line4055"></a>        return result;
<a name="__line4056"></a>    }
<a name="__line4057"></a>
<a name="__line4058"></a>    function date2epoch(const var &amp;format)
<a name="__line4059"></a>    {
<a name="__line4060"></a>        return new function_core::date2epoch(format);
<a name="__line4061"></a>    }
<a name="__line4062"></a>
<a name="__line4063"></a>    function cross_product(const function &amp;x1, const function &amp;x2)
<a name="__line4064"></a>    {
<a name="__line4065"></a>        if(x1.components() != 3 || x2.components() != 3) return function(unset,unset,unset);
<a name="__line4066"></a>        return function(
<a name="__line4067"></a>            x1[1]*x2[2]-x1[2]*x2[1],
<a name="__line4068"></a>            x1[2]*x2[0]-x1[0]*x2[2],
<a name="__line4069"></a>            x1[0]*x2[1]-x1[1]*x2[0]
<a name="__line4070"></a>            );
<a name="__line4071"></a>    }
<a name="__line4072"></a>
<a name="__line4073"></a>    function dot(const function &amp;x1, const function &amp;x2)
<a name="__line4074"></a>    {
<a name="__line4075"></a>        if(x1.components() != 3 || x2.components() != 3) return unset;
<a name="__line4076"></a>        return x1[0]*x2[0]+x1[1]*x2[1]+x1[2]*x2[2];
<a name="__line4077"></a>    }
<a name="__line4078"></a>
<a name="__line4079"></a>    <span class=comment>// Normalize the vector-function to the given norm. v must have 3 components</span>
<a name="__line4080"></a>    function normalize(const function &amp;v, double norm)
<a name="__line4081"></a>    {
<a name="__line4082"></a>        if(v.components() != 3) return unset;
<a name="__line4083"></a>        return function (
<a name="__line4084"></a>            v[0]/sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]),
<a name="__line4085"></a>            v[1]/sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]),
<a name="__line4086"></a>            v[2]/sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])
<a name="__line4087"></a>            );
<a name="__line4088"></a>    }
<a name="__line4089"></a>}
<a name="__line4090"></a>
<a name="__line4091"></a>
<a name="__line4092"></a>blop::function operator==(const blop::function &amp;f1, const blop::function &amp;f2)
<a name="__line4093"></a>{
<a name="__line4094"></a>    return blop::operator==(f1,f2);
<a name="__line4095"></a>}
<a name="__line4096"></a>blop::function operator&lt;(const blop::function &amp;f1, const blop::function &amp;f2)
<a name="__line4097"></a>{
<a name="__line4098"></a>    return blop::operator&lt;(f1,f2);
<a name="__line4099"></a>}
<a name="__line4100"></a>blop::function operator&gt;(const blop::function &amp;f1, const blop::function &amp;f2)
<a name="__line4101"></a>{
<a name="__line4102"></a>    return blop::operator&gt;(f1,f2);
<a name="__line4103"></a>}
<a name="__line4104"></a>
<a name="__line4105"></a>

</pre>
<hr> 
<a href="../index.html" title="Home"> 
<img src="../home.png"  style="border-width:0cm;"> 
</a>
<a href="source.html" title="List of sourcefiles"> 
<img src="../up.png"    style="border-width:0cm;"> 
</a>

</body></html>
