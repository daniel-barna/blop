#!/bin/bash

# short description: convert .beps files to .bmp

. @config@

help()
{
cat <<EOF

Usage: beps2bmp [any beps2eps option] [-comment <text>] inputfile [outputfile]

   -comment <text>     write 'text' into the comment field of
                       the output jpeg file

   -r <number>         specify the resolution of the bmp file
                       default is $resolution

   for the beps2eps options say: beps2eps --help

   Return code:
     0   - in case of success
     1   - no inputfile specified
     2   - inputfile does not exist
     3   - mktemp failed
     6   - convert failed
     or the error code of beps2eps, if that failed
EOF
}

if [ $# -lt 1 ] ; then
    echo Filename expected 1>&2
    help;
    exit 1;
fi

if [ "$1" = "--help" ] ; then
    help;
    exit;
fi

if [ "$1" = "-h" -a $# = 1 ] ; then
    help;
    exit;
fi


tmpfiles=""
abort()
{
    if [ "$tmpfiles" != "" ] ; then rm -f $tmpfiles; fi
    exit $1
}
trap abort 0 1 2 3 7 13 15

beps2eps_options=();
resolution=200;
transparent="";
inputfile=""
outputfile=""
quiet=false;
comment="--comment=Produced on `date` by BLOP (http://blopplot.sourceforge.net)"


while [ $# -gt 0 ] ; do
    # ask beps2eps if it accepts this cmd line arg
    resp=`beps2eps --cmd-line-arg-accepted $1`
    # if yes, store it into the beps2eps_options variable
    if [ "$resp" != "" ] ; then
        #echo beps2eps accepts argument $1, needs $resp more
        beps2eps_options+=("$1");
        for i in `seq 1 $resp`; do
            shift;
            beps2eps_options+=("$1");
        done
    else
        case $1 in
            -comment) comment="--comment='$2'"; shift;;
            -r)  resolution=$2; shift;;
            *)  if [ "$inputfile" = "" ] ; then
                    inputfile=$1
                else
                    outputfile=$1
                fi ;;
        esac
    fi
  shift;
done

if [ "$inputfile" = "" ] ; then
  echo No inputfile specified
  abort 1;
fi

if [ ! -e "$inputfile" ] ; then
  echo Inputfile "$inputfile" does not exist
  abort 2;
fi

if [ "$outputfile" = "" ] ; then
  outputfile=`basename $inputfile .beps`.bmp
fi

input_full=`readlink -f "$inputfile"`
output_full=`readlink -f "$outputfile"`
if [ "$input_full" = "$output_full" ] ; then
   echo "ERROR: both input and output point to the same file"
   abort 3   
fi

tmp1=`mktemp /tmp/beps2bmp-1-XXXXXX`
if [ $? -ne 0 ] ; then
  echo Temprary file creation failed
  abort 3;
fi
tmpfiles="$tmpfiles $tmp1"

if [ $quiet = true ] ; then
  beps2eps_output=$(beps2eps "${beps2eps_options[@]}" "$inputfile" "$tmp1" 2>&1)
  beps2eps_code=$?
else
  beps2eps "${beps2eps_options[@]}" "$inputfile" "$tmp1"
  beps2eps_code=$?
fi

if [ $beps2eps_code -ne 0 ] ; then
  echo $beps2eps_output
  echo %%%
  echo %%% beps2eps failed
  echo %%%
  abort $beps2eps_code
fi

convert -density "$resolution" "$tmp1" bmp:"$outputfile"
if [ $? != 0 ] ;then
  echo The following command failed:
  echo convert "$transparent" -density "$resolution" "$tmp1" "$outputfile"
  abort 6
fi
rm -f $tmpfiles
exit 0;

# old code. never managed to make the png size be correct..... so switched instead to 'convert'

tmp2=`mktemp /tmp/beps2bmp-2-XXXXXX`
if [ $? -ne 0 ] ; then
  exit 3;
fi

# get the bounding box from the intermediary .eps file
width=`awk '$1=="%%BoundingBox:" {print $4; exit;}' $tmp1`
height=`awk '$1=="%%BoundingBox:" {print $5; exit;}' $tmp1`
PAPERSIZE="-dDEVICEWIDTHPOINTS=$width -dDEVICEHEIGHTPOINTS=$height"

if [ $quiet = false ] ; then
  gs $PAPERSIZE -dBATCH -dNOPAUSE -sDEVICE=pnmraw -dTextAlphaBits=4 -dGraphicsAlphaBits=0 -r$resolution -sOutputFile=$tmp2 $tmp1
else
  gs_output=`gs $PAPERSIZE -dBATCH -dNOPAUSE -sDEVICE=pnmraw -dTextAlphaBits=4 -dGraphicsAlphaBits=0 -r$resolution -sOutputFile=$tmp2 $tmp1 2>&1`
fi

if [ $? -ne 0 ] ; then
  echo $gs_output
  echo %%%
  echo %%% gs failed
  echo %%%
  exit 6
fi

pnmcrop -white $tmp2 | pnmtojpeg  "$comment"  > $outputfile

if [ $? -ne 0 ] ; then
  echo %%%
  echo %%% pnmcrop or pnmtojpeg failed
  echo %%%
  exit 7
fi

rm -f $tmp1 
rm -f $tmp2

exit 0;


